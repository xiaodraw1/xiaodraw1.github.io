{"meta":{"title":"xiaodraw","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"search","date":"2024-02-28T09:40:33.000Z","updated":"2024-02-28T09:40:33.974Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"java学习笔记","slug":"java学习笔记","date":"2024-02-04T10:36:16.000Z","updated":"2024-03-09T11:18:09.116Z","comments":true,"path":"2024/02/04/java学习笔记/","link":"","permalink":"http://example.com/2024/02/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[TOC] 注释当行注释：&#x2F;&#x2F;注释信息多行注释：&#x2F;注释信息&#x2F; （两杠内侧各有一个*） 关键字类比成语可以简化内容，如文质彬彬：形容人有礼貌关键字：java语言赋予的特定含义单词常用关键字：public，class，static，void。编译器中，写出关键字的时候会自带特殊颜色 常量值是确定的。字符串常量：用双引号括起来，字符串是由字符串联起来的，字符常量和字符串常量是两个概念整数常量：不带小数点的数字小数常量:..字符常量：用单引号括起来布尔常量：表真假，只有两种结果空常量：一个特殊的值，null输出常量值：System.out.println()。括号里要不要加引号取决于输出的数据类型 变量变量的值存放在内存条中常见问题1.不能同时对一个变量赋两种类型，比如先int b再char b；2.定义小数时，要在后面加f或者d，不加默认为d。比如float a&#x3D;3.14，a的类型为单精度，但是后面没加f，所以会矛盾 标识符给类，方法，变量等起的名字。可以包含26字母，0-9，美元符号和下划线(#不行)规则(硬性要求)：不能以数字开头；不能是关键字(class不可以，但是Class可以)软性要求：标识符要尽量能让别人看懂是什么意思，最好别取aaa这种名字为了满足软性要求，需要使用大小驼峰命名法。这种方法只作用于标识符中每个单词的首字母 小驼峰命名法针对方法和变量使用约定1：标识符仅一个单词时，首字母(注意这里为什么不说是全部，这是因为方便和大驼峰作对比）小写int a约定2：标识符由多个单词组成时，第一个单词的首字母小写，其余单词的首字母大写int firstAge 大驼峰命名法针对类使用约定1：标识符是一个单词的时候，首字母大写约定2：标识符是多个单词的时候，每个单词的首字母大写 类型转换自动类型转换原理：不同类型数据在内存中占的字节不同，int类型占4字节,double类型占8字节。如果用下面的句子double a&#x3D;10因为声明了a是double类型（以声明的类型为准），所以a会由赋值的10自动转换为10.00.但是，char类型不能自动转换为数字类型比如，double a&#x3D;10，char b&#x3D;a，这时会报错 强制类型转换和自动相反，从字节大的数据转化为字节小的数据int a&#x3D;99.99，默认a是int这种方法的缺点是会损耗精度，还有可能会丢失数据，一般会报错 字符的＋操作多个类型的数据相加时，遵循以下规则char类型的数据转换成ascii码，其他非字符类型的数据转换成其中占字节最多的数据类型例如，char q&#x3D;‘a’，int a&#x3D;10，float b&#x3D;10.00，则q+a+b&#x3D;117.00，因为q被转换成了97，a转换成了10.00占字节数排序(从小到大)：byte short char int long float double 字符串的＋操作字符串没有ascii码，所以跟int类型数据相加时不能用上面的方法，直接做连接操作例如，int a&#x3D;10，int b&#x3D;10则a+b+“abc”&#x3D;&#x3D;20abc，但是a+“abc”+b&#x3D;&#x3D;10abc10因为加法是从左到右 i++的易错点总结：i++是先将i加入操作中然后再加1，++i是先将i+1再将i加入操作int x&#x3D;10，int y&#x3D;x++ + x++ + x++第一个x++的值是10(操作为将i的值作为第一个加数），第二个x++的值是11，第三个x++的值是12，所以y的值为33 关系运算符关系运算符的结果是bool类型，只有true和false两种 逻辑运算符逻辑异或(^)：a^b时，ab真值不同，返回true，ab真值相同时返回false。个人理解，异指的是ab的真值相反，或指的是a真b假或a假b真 短路逻辑运算符普通逻辑运算符只有一个符号，比如|，&amp;等。短路逻辑运算符变成了两个，比如a&amp;&amp;b。顾名思义，具有短路作用，如果a是假的，就不会再去运行b(如果b是i++&lt;100这种，i就不会自增了，因为不会运行这一句)，而普通的逻辑运算符没有此功能程序里面最好用短路，这样可以提高效率 三元运算符格式：关系表达式?a:b。如果关系表达式的返回值为true，则输出a，否则输出b使用三元运算符可以减少代码量 Scanner(打印机)作用类似于c语言里的input，使用方法如下1.导包 import java.util.Scanner 这步必须在定义类之前2.创建对象 Scanner sc&#x3D;new Scanner(System.in)3.接收数据 int i&#x3D;sc.nextInt(注意这里i是大写)这样就把用户输入的值赋给了i 流程控制语句一共有三种结构，顺序，分支，循环 if语句跟c语言里的差不多 switch语句格式如下switch(表达式) case 值1： 语句体1； break； case 值2： 语句体2； break；。。。 default： 语句体n； break；}表达式：可以是各种类型的数据case：要和表达式进行比较的值语句体：一系列操作break：表示中断，结束的意思，可以控制switch的结束，执行了break之后就不会再运行下面的句子了，直接跳出switchdefault：当所有的值都和表达式不匹配时，执行default下面的语句，相当于多重if语句里最后的else 小细节1.如果表达式和case匹配之后(注意是匹配之后，有可能是第二个case)，这行操作后面没有break，接下来的case不管有没有匹配，其下面的操作都会执行，直到出现break。举例如下case 1:print(春);break;case 2:print(夏);case 3:print(秋)；case 4:print(冬);break;此时输入number&#x3D;1之后只会输出春，但是输入2的话会输出夏秋冬 2.如果有几个case对应同一操作的话，可以写成下面这样简化代码case 1：case 2：case 3： 操作； break； for循环语句也是跟c语言差不多，要注意一下运行的逻辑，判断完i符合条件之后，先进行下面的操作，再将i+1.可以想象成一个逆时针的顺序 while循环语句格式如下while(判断条件语句){ 循环体语句； 控制条件语句(例如i++这种)；} do while循环语句格式如下do{ 循环体语句； 条件控制语句；}while(条件判断语句)；其实就是while语句换了个形式 死循环将循环变成死循环：去除掉条件控制语句(例如i++这种)，这样可以让循环体语句一直执行死循环会让cpu使用率飙升 三种循环语句的区别for循环中i的值只能在循环体里面使用(因为i是在for循环里定义的)while循环里的i由于是在外部定义的，因此可以在外部使用 break和continue的区别break：结束所在的循环continue：继续下次循环 Random随机数作用：随机产生一个随机数。使用步骤如下导包：import java.util.Random;创建对象：Random r&#x3D;new Random();获取随机数：int number&#x3D;r.nextInt(10)。数据的范围：0到10，包括0但不包括10。 猜随机数要求：生成一个随机数，当用户输入值小于该数时，输出”太小了”，当输入值大于该数时，输出”太大了”。匹配则输出”恭喜”思路：首先想到要用循环，而且用不了for，所以只能while。然后确定判断条件语句，用a！&#x3D;b，循环体里面用if。代码如下 123456789while(i!=j)&#123; if(j&gt;i)&#123; System.out.println(&quot;太大了&quot;); j=sc.nextInt(); &#125; if(j&lt;i)&#123; System.out.println(&quot;太小了&quot;); j=sc.nextInt(); &#125; idea使用idea创建项目1.创建一个空项目2.在该项目下创建新的模块3.在该模块下的src创建一个包(一个文件夹)4.在该包下新建一个类5.在该类下编写代码如果报错显示找不到或无法加载主类… ，点击界面上方的build project，清除一些缓存 idea快捷键可能会跟qq等软件冲突，最好关掉这些软件的快捷键快速生成main()方法：法一：输入psvm(public static void main的缩写)，idea会弹出词条法二(懒人版）：输入m，只有这一个词条快速生成输出语句(只有在自己定义的类里面可以使用）：sout+回车注释：单行：全选，按住ctrl+&#x2F;(再按一下就是取消)多行：全选，按住ctrl+alt+&#x2F;但其实据我观察，无论是单行还是多行，都可以只按ctrl加&#x2F;格式化：ctrl+alt+l。不是清空，是让代码更加工整 数组定义数组的格式：法一(推荐)：int [] arr，这句话的意思是定义了一个int类型的数组，数组的名字是arr。法二：int arr []，这句话的意思是定义了一个int类型的变量，变量名是arr数组 数组初始化java中的数组必须先初始化才能使用。初始化：为数组中的每个元素分配内存空间，并为每个数组元素赋值初始化方式分动态和静态两种动态初始化：只指定数组长度，由系统为数组分配初始值。形式如下new 数据类型[数组长度]静态初始化:格式如下int[] arr&#x3D;new int[]{1，2，3}；或者直接int[] arr&#x3D;{1,2,3}; 单个数组访问的原理数组内存分配：java程序为了提高运算效率，在内存中对空间进行了不同区域的划分，每一篇区域都有特定的管理方式jdk内存空间分为：堆，栈，方法区，本地方法栈等假设进行如下操作：int [] arr&#x3D;new int [4];sout(arr);此时输出的结果是该数组的内存地址。这是因为，当new int [4]时，会先在堆内存空间里开辟一块空间，这块空间用来存放数组的四个元素，而int [] arr定义的数组存放在栈空间里。堆空间里存放了很多new出来的数组空间，除了上面的arr还有其他的数组空间，所以需要知道指定数组的地址才能找到指定的数组空间，而这个地址赋值给了栈空间里的arr以及各种数组如果把上面改成sout(arr[0-3]),则输出的结果全是0，这是因为数组在初始化时会为存储空间添加默认值。int类型的数组全部默认为0，浮点数类型默认为0.0，布尔类型默认为false栈内存：用来存储局部变量堆内存：存储的都是实体(对象)，即new建立的空间栈空间通过内存地址访问堆内存空间动态初始化的整个流程(用上面的例子):new int[4]在堆空间里生成了一块特定的空间用来存放四个元素，int[] arr在栈空间里生成了一个int类型的数组，new出来的空间将地址赋给了arr，在输入sout(arr[0])时，先通过arr的地址访问堆空间中的特定空间，然后访问下标为0的元素如果进行了int[] arr2&#x3D;arr1的操作，则把arr1的地址赋值给arr2 如何遍历数组获取数组的长度：arr.length遍历：用for循环，i&lt;arr.length 方法具有特殊功能的代码集，和c语言里的自定义函数是一个东西 方法的定义与调用定义：ps+返回值类型+方法名(参数){方法体；return 返回值(这步只有在上面不为void的时候要加)}调用：方法名(参数)；注意：不能在方法里面定义方法；方法定义不能在main主程序里面方法的定义与调用也可以通过栈来理解。主程序的main方法先被压入栈底，然后再压入定义的方法。所以调用的时候定义的方法先出栈 形参和实参形参：方法定义中的参数实参：方法调用中的参数 带返回值的方法条件：把public static void 中的void改成具体的返回值类型，然后在方法体的下面加一行return返回值可以将返回值传递给其他参数，如int i&#x3D;geimax(a,b)，return的值是两数中更大的那个 方法的重载指的是同一个类中定义的多个方法之间的关系，这些方法满足下列条件：1.多个方法在同一个类中2.多个方法具有相同的方法名3.多个方法的参数类型不同，类型不同或者数量不同简单来说，一个类中不允许创建两个一模一样的方法，但是只要在接收的参数不同(类型或者数量)的情况下，两个方法的名字是可以一样的特点：仅针对于方法的定义，与方法的调用，以及返回值都无关，不能通过两个方法的返回值判断是否重载；两个方法必须要在同一个类中 方法的参数传递基本类型形参值的改变不会影响实参假如定义以下 void change( int number)方法：number&#x3D;20;主程序如下：int number&#x3D;10;change(number);在运行完主程序以后，number的值依旧为10. 方法的参数传递引用类型引用类型的形参(如数组)值的改变会影响实参假如把上面的例子改成如下，number变成(int[] arr),arr[0]&#x3D;10。主程序中，int[] arr&#x3D;new int[4],change(arr)，则最后arr[0]会变成10。 原理这个例子和上面的区别在于，这个change接收的是数组的地址，而上面的change接受的只是一个数字。上面的参数number只是名字和实参number一样，但是接收的时候只接收一个普通数字。下面的change方法在接收数组时，接收的是数组的地址，所以会指向堆中对应的数组","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-01-26T09:14:51.153Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2024/01/26/hello-world/","link":"","permalink":"http://example.com/2024/01/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}