[{"title":"Hello World","url":"/2024/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java学习笔记","url":"/2024/02/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"[TOC]\n注释当行注释：&#x2F;&#x2F;注释信息多行注释：&#x2F;注释信息&#x2F; （两杠内侧各有一个*）\n\n关键字类比成语可以简化内容，如文质彬彬：形容人有礼貌关键字：java语言赋予的特定含义单词常用关键字：public，class，static，void。编译器中，写出关键字的时候会自带特殊颜色\n\n常量值是确定的。字符串常量：用双引号括起来，字符串是由字符串联起来的，字符常量和字符串常量是两个概念整数常量：不带小数点的数字小数常量:..字符常量：用单引号括起来布尔常量：表真假，只有两种结果空常量：一个特殊的值，null输出常量值：System.out.println()。括号里要不要加引号取决于输出的数据类型数据类型分基本数据类型和引用类型，上面的这些都是基本数据类型，创建对象则为引用类型，引用类型后面会讲\n\n变量变量的值存放在内存条中常见问题1.不能同时对一个变量赋两种类型，比如先int b再char b；2.定义小数时，要在后面加f或者d，不加默认为d。比如float a&#x3D;3.14，a的类型为单精度，但是后面没加f，所以会矛盾\n\n标识符给类，方法，变量等起的名字。可以包含26字母，0-9，美元符号和下划线(#不行)规则(硬性要求)：不能以数字开头；不能是关键字(class不可以，但是Class可以)软性要求：标识符要尽量能让别人看懂是什么意思，最好别取aaa这种名字为了满足软性要求，需要使用大小驼峰命名法。这种方法只作用于标识符中每个单词的首字母\n小驼峰命名法针对方法和变量使用约定1：标识符仅一个单词时，首字母(注意这里为什么不说是全部，这是因为方便和大驼峰作对比）小写int a约定2：标识符由多个单词组成时，第一个单词的首字母小写，其余单词的首字母大写int firstAge\n大驼峰命名法针对类使用约定1：标识符是一个单词的时候，首字母大写约定2：标识符是多个单词的时候，每个单词的首字母大写\n\n类型转换自动类型转换原理：不同类型数据在内存中占的字节不同，int类型占4字节,double类型占8字节。如果用下面的句子double a&#x3D;10因为声明了a是double类型（以声明的类型为准），所以a会由赋值的10自动转换为10.00.但是，char类型不能自动转换为数字类型比如，double a&#x3D;10，char b&#x3D;a，这时会报错\n强制类型转换和自动相反，从字节大的数据转化为字节小的数据int a&#x3D;99.99，默认a是int这种方法的缺点是会损耗精度，还有可能会丢失数据，一般会报错\n\n字符的＋操作多个类型的数据相加时，遵循以下规则char类型的数据转换成ascii码，其他非字符类型的数据转换成其中占字节最多的数据类型例如，char q&#x3D;‘a’，int a&#x3D;10，float b&#x3D;10.00，则q+a+b&#x3D;117.00，因为q被转换成了97，a转换成了10.00占字节数排序(从小到大)：byte short char int long float double\n\n字符串的＋操作字符串没有ascii码，所以跟int类型数据相加时不能用上面的方法，直接做连接操作例如，int a&#x3D;10，int b&#x3D;10则a+b+“abc”&#x3D;&#x3D;20abc，但是a+“abc”+b&#x3D;&#x3D;10abc10因为加法是从左到右\n\ni++的易错点总结：i++是先将i加入操作中然后再加1，++i是先将i+1再将i加入操作int x&#x3D;10，int y&#x3D;x++ + x++ + x++第一个x++的值是10(操作为将i的值作为第一个加数），第二个x++的值是11，第三个x++的值是12，所以y的值为33\n\n关系运算符关系运算符的结果是bool类型，只有true和false两种\n\n逻辑运算符逻辑异或(^)：a^b时，ab真值不同，返回true，ab真值相同时返回false。个人理解，异指的是ab的真值相反，或指的是a真b假或a假b真\n短路逻辑运算符普通逻辑运算符只有一个符号，比如|，&amp;等。短路逻辑运算符变成了两个，比如a&amp;&amp;b。顾名思义，具有短路作用，如果a是假的，就不会再去运行b(如果b是i++&lt;100这种，i就不会自增了，因为不会运行这一句)，而普通的逻辑运算符没有此功能程序里面最好用短路，这样可以提高效率\n\n三元运算符格式：关系表达式?a:b。如果关系表达式的返回值为true，则输出a，否则输出b使用三元运算符可以减少代码量\n\nScanner(打印机)作用类似于c语言里的input，使用方法如下1.导包 import java.util.Scanner 这步必须在定义类之前2.创建对象 Scanner sc&#x3D;new Scanner(System.in)3.接收数据 int i&#x3D;sc.nextInt(注意这里i是大写)这样就把用户输入的值赋给了i\n\n流程控制语句一共有三种结构，顺序，分支，循环\nif语句跟c语言里的差不多\n\nswitch语句格式如下switch(表达式)    case 值1：        语句体1；        break；    case 值2：        语句体2；        break；。。。    default：        语句体n；        break；}表达式：可以是各种类型的数据case：要和表达式进行比较的值语句体：一系列操作break：表示中断，结束的意思，可以控制switch的结束，执行了break之后就不会再运行下面的句子了，直接跳出switchdefault：当所有的值都和表达式不匹配时，执行default下面的语句，相当于多重if语句里最后的else\n小细节1.如果表达式和case匹配之后(注意是匹配之后，有可能是第二个case)，这行操作后面没有break，接下来的case不管有没有匹配，其下面的操作都会执行，直到出现break。举例如下case 1:print(春);break;case 2:print(夏);case 3:print(秋)；case 4:print(冬);break;此时输入number&#x3D;1之后只会输出春，但是输入2的话会输出夏秋冬\n2.如果有几个case对应同一操作的话，可以写成下面这样简化代码case 1：case 2：case 3：    操作；    break；\n\nfor循环语句也是跟c语言差不多，要注意一下运行的逻辑，判断完i符合条件之后，先进行下面的操作，再将i+1.可以想象成一个逆时针的顺序\n\nwhile循环语句格式如下while(判断条件语句){    循环体语句；    控制条件语句(例如i++这种)；}\ndo while循环语句格式如下do{    循环体语句；    条件控制语句；}while(条件判断语句)；其实就是while语句换了个形式\n\n死循环将循环变成死循环：去除掉条件控制语句(例如i++这种)，这样可以让循环体语句一直执行死循环会让cpu使用率飙升\n\n三种循环语句的区别for循环中i的值只能在循环体里面使用(因为i是在for循环里定义的)while循环里的i由于是在外部定义的，因此可以在外部使用\n\nbreak和continue的区别break：结束所在的循环continue：继续下次循环\n\nRandom随机数作用：随机产生一个随机数。使用步骤如下导包：import java.util.Random;创建对象：Random r&#x3D;new Random();获取随机数：int number&#x3D;r.nextInt(10)。数据的范围：0到10，包括0但不包括10。\n\n猜随机数要求：生成一个随机数，当用户输入值小于该数时，输出”太小了”，当输入值大于该数时，输出”太大了”。匹配则输出”恭喜”思路：首先想到要用循环，而且用不了for，所以只能while。然后确定判断条件语句，用a！&#x3D;b，循环体里面用if。代码如下\nwhile(i!=j)&#123;    if(j&gt;i)&#123;        System.out.println(&quot;太大了&quot;);        j=sc.nextInt();    &#125;    if(j&lt;i)&#123;        System.out.println(&quot;太小了&quot;);        j=sc.nextInt();    &#125;\n\nidea使用idea创建项目1.创建一个空项目2.在该项目下创建新的模块3.在该模块下的src创建一个包(一个文件夹)4.在该包下新建一个类5.在该类下编写代码如果报错显示找不到或无法加载主类… ，点击界面上方的build project，清除一些缓存\n\nidea快捷键可能会跟qq等软件冲突，最好关掉这些软件的快捷键快速生成main()方法：法一：输入psvm(public static void main的缩写)，idea会弹出词条法二(懒人版）：输入m，只有这一个词条快速生成输出语句(只有在自己定义的类里面可以使用）：sout+回车注释：单行：全选，按住ctrl+&#x2F;(再按一下就是取消)多行：全选，按住ctrl+alt+&#x2F;但其实据我观察，无论是单行还是多行，都可以只按ctrl加&#x2F;格式化：ctrl+alt+l。不是清空，是让代码更加工整转大写：选中，ctrl+shift+u自动生成代码：ctrl+alt+v在idea中可以在new对象时自动为这个对象起名字等等生成初始化代码，简单来说就是自动生成等式左边的内容\n\n数组定义数组的格式：法一(推荐)：int [] arr，这句话的意思是定义了一个int类型的数组，数组的名字是arr。法二：int arr []，这句话的意思是定义了一个int类型的变量，变量名是arr数组\n\n数组初始化java中的数组必须先初始化才能使用。初始化：为数组中的每个元素分配内存空间，并为每个数组元素赋值初始化方式分动态和静态两种动态初始化：只指定数组长度，由系统为数组分配初始值。形式如下new 数据类型[数组长度]静态初始化:格式如下int[] arr&#x3D;new int[]{1，2，3}；或者直接int[] arr&#x3D;{1,2,3};\n\n单个数组访问的原理数组内存分配：java程序为了提高运算效率，在内存中对空间进行了不同区域的划分，每一篇区域都有特定的管理方式jdk内存空间分为：堆，栈，方法区，本地方法栈等假设进行如下操作：int [] arr&#x3D;new int [4];sout(arr);此时输出的结果是该数组的内存地址。这是因为，当new int [4]时，会先在堆内存空间里开辟一块空间，这块空间用来存放数组的四个元素，而int [] arr定义的数组存放在栈空间里。堆空间里存放了很多new出来的数组空间，除了上面的arr还有其他的数组空间，所以需要知道指定数组的地址才能找到指定的数组空间，而这个地址赋值给了栈空间里的arr以及各种数组如果把上面改成sout(arr[0-3]),则输出的结果全是0，这是因为数组在初始化时会为存储空间添加默认值。int类型的数组全部默认为0，浮点数类型默认为0.0，布尔类型默认为false栈内存：用来存储局部变量堆内存：存储的都是实体(对象)，即new建立的空间栈空间通过内存地址访问堆内存空间动态初始化的整个流程(用上面的例子):new int[4]在堆空间里生成了一块特定的空间用来存放四个元素，int[] arr在栈空间里生成了一个int类型的数组，new出来的空间将地址赋给了arr，在输入sout(arr[0])时，先通过arr的地址访问堆空间中的特定空间，然后访问下标为0的元素如果进行了int[] arr2&#x3D;arr1的操作，则把arr1的地址赋值给arr2\n\n如何遍历数组获取数组的长度：arr.length遍历：用for循环，i&lt;arr.length\n\n方法具有特殊功能的代码集，和c语言里的自定义函数是一个东西\n\n方法的定义与调用定义：ps+返回值类型+方法名(参数){方法体；return 返回值(这步只有在上面不为void的时候要加)}调用：方法名(参数)；注意：不能在方法里面定义方法；方法定义不能在main主程序里面方法的定义与调用也可以通过栈来理解。主程序的main方法先被压入栈底，然后再压入定义的方法。所以调用的时候定义的方法先出栈\n\n形参和实参形参：方法定义中的参数实参：方法调用中的参数\n\n带返回值的方法条件：把public static void 中的void改成具体的返回值类型，然后在方法体的下面加一行return返回值可以将返回值传递给其他参数，如int i&#x3D;geimax(a,b)，return的值是两数中更大的那个\n\n方法的重载指的是同一个类中定义的多个方法之间的关系，这些方法满足下列条件：1.多个方法在同一个类中2.多个方法具有相同的方法名3.多个方法的参数类型不同，类型不同或者数量不同简单来说，一个类中不允许创建两个一模一样的方法，但是只要在接收的参数不同(类型或者数量)的情况下，两个方法的名字是可以一样的特点：仅针对于方法的定义，与方法的调用，以及返回值都无关，不能通过两个方法的返回值判断是否重载；两个方法必须要在同一个类中\n\n方法的参数传递基本类型形参值的改变不会影响实参假如定义以下 void change( int number)方法：number&#x3D;20;主程序如下：int number&#x3D;10;change(number);在运行完主程序以后，number的值依旧为10.\n\n方法的参数传递引用类型引用类型的形参(如数组)值的改变会影响实参假如把上面的例子改成如下，number变成(int[] arr),arr[0]&#x3D;10。主程序中，int[] arr&#x3D;new int[4],change(arr)，则最后arr[0]会变成10。\n原理这个例子和上面的区别在于，这个change接收的是数组的地址，而上面的change接受的只是一个数字。上面的参数number只是名字和实参number一样，但是接收的时候只接收一个普通数字。下面的change方法在接收数组时，接收的是数组的地址，所以会指向堆中对应的数组\n\ndebugbug：指程序发生了错误debug：程序调试工具，可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序\n\n操作流程1.设置断点在行号后面的区域单击鼠标左键，此时将该行标记后，调试将从该行开始2.调试程序在开始调试后，点击f8(step over,步过)，可以查看每一步对应的结果也可以按f9，f9的作用是在有几个断点的情况下，快速跳到下一个断点\n\n断点调试如何设置条件假如有如下代码：for(int i&#x3D;0;i&lt;10;i++){sout(i);}在sout这行设置断点，然后一直f8，程序会把10次的结果全部跑一遍。如果只想看i&#x3D;8时的输出结果，在断点上面单机右键，可以设置条件。在条件中输入i&#x3D;&#x3D;8即可\n\nidea在debug模式下修改变量的值调试模式下可以看到某个变量在某一步的值，右键这个值，按f2(设置值)可以更改该变量\n\n栈帧链假如有如下代码：psv a(){sout(‘a’);b();}\npsv b(){sout(‘b’);c();}\npsv c(){sout(‘c’);a();}psvm{a();}\n从出入栈的角度来分析，先定义的方法是a，然后是b，最后是c，所以入栈顺序是a，b，c。因为栈遵循先进后出的原则，所以调用时的先后顺序为cba栈帧可以理解为方法，上面这段代码里一共有三个栈帧栈帧链对后期知识的学习有帮助\n\n面向对象对象：客观存在的事物类：可以简单的描述为对现实事物的一种描述，即具有相同属性和行为(属性和行为是对象的两个特征)的一组对象的集合例如，各种手机都有品牌名称，品牌价格，品牌规格等属性，因此手机是一个类。而小米，oppo，苹果这些手机都是实体，即对象对象行为：对象能够执行的操作类不是真实存在的，而是一个抽象的概念在idea中，一个包里可以同时存在很多个类，这些类可以互相调用方法\n\n类的组成(属性和行为)属性在类中通过成员变量来体现(类中方法外的变量)行为在类中通过成员方法来体现(和前面的方法相比去掉static关键字)\n\n类的定义步骤1.定义类2.定义成员变量(各种属性)3.定义成员方法（各种行为）用代码表示出来就很熟悉了public class 类名{1.成员属性2.成员方法(这里的方法定义时要去掉static)}\n\n对象的使用1.创建对象格式：类名 对象名&#x3D;new 类名();例子：Phone phone1&#x3D;new Phone()；这里p大写是因为phone是一个类2.使用成员变量(这里的成员变量&#x3D;属性)格式：对象名称.变量例子：phone1.brand&#x3D;“xiaomi”；3.使用成员方法(这里的成员方法&#x3D;行为)格式：对象名称.方法名例子：phone1.call();之前学的scanner也是这个，相当于调用了scanner类的nextInt方法，int i&#x3D;sc.nextInt\n\n成员变量与局部变量成员变量：类中方法外的变量(上面类的定义里说了，相当于对象的属性)局部变量：方法里的变量个人理解，类中包含成员变量和成员方法，成员变量占一部分，而局部变量在另一部分里面。可以用一个很简单的方法判断，成员变量在定义时可以不带值，比如int age，而局部变量在定义时要带具体值，如int i&#x3D;1。其他区别：1.成员变量存放在堆内存中，局部变量存放在栈内存中2.成员变量随对象存在而存在(因为成员变量是对象的属性)，局部变量随方法调用而存在，随方法结束消失要注意，定义的方法里的形参也是局部变量如果要给类里的某个成员变量赋个初始值，用this。比如this.age&#x3D;123，这样就把123赋值给了成员变量age。this要在成员方法内使用思考：为什么不先创建一个对象，然后把他的age改为123因为各个对象虽然属于同一类，但是他们的地址并不相同，只改其中一个对象的age，没法对其他对象产生影响\n\n权限修饰符一共有四种，分别是private，default，protected，public，不加的话默认为default。权限修饰符可以使用在方法，属性，类\n这四种一定要记住，面试要考\n用法：限定能够访问的对象，比如在定义成员变量或成员方法的语句前加一个private，如private int age，可以让其只能在该类中访问，不被其他类使用(一个包中可以有很多个类，可以用new 类1在类2中定义一个对象)。四种修饰符只在限定的范围上有区别\nprivate：只能在本类中被访问\ndefault：可以在同一个类和同一个包中被访问，超过这个则不行\nprotected：在default的基础上，再加一个不同包的子类(这个子类要继承该类)\npublic：怎样都行记忆的时候可以按照这个顺序\n\nget和set方法set：在类里定义一个方法，这个方法的作用是为成员变量赋值，之所以不直接用this赋值，是因为要判断赋的值符不符合条件，例子如下public void setAge(int age){if(条件){this.age&#x3D;age;}}在这个set方法中，只有当接收的age符合条件后才会将其赋值给成员变量ageget：直接获取成员变量的值。用法：对象名.get属性名(下面会讲)快捷方法：单击鼠标右键，点击生成，里面有get和set方法get和set在封装里面能用上\n\nthis关键字具体用法：在成员方法里使用，可以配合set方法。public void getAge(int age){this.age&#x3D;age;}调用这个方法的一般是对象，this和该对象对应举个例子，定义一个手机类，想为其赋值，可以用Mobile.getAge()\n\n构造方法一种特殊的方法，可以初始化对象或者为成员变量赋值，格式如下public class 类名{    修饰符 类名(参数){  }}构造方法的名字一定要与类名相同，分有参构造和无参构造\n无参构造跟前面一样的形式，如Student  st&#x3D;new Student()，new是修饰符。用来生成该类的对象。new的作用：在堆内生成一块空间。student()的作用：无参构造，在括号内加上参数即为有参构造\n有参构造可以传递参数，为对象中的成员赋值修饰符 类名(参1，参2,…，参n){this.name&#x3D;参1；…}\n也可以用类名 对象名&#x3D;new 类名（参数1，参数2，。。），这个是有参构造\n要注意，类中至少有一个构造方法，如果用户没定义的话，系统会自动生成一个。如果用户定义了一个有参构造的话，系统的那个会失效，此时Student st&#x3D;new Student()会报错s\n\n封装面向对象的三个基本特征(封装，继承，多态)之一封装，指的是把客观事物封装成抽象的类，并且该类可以把自己的方法和数据只让可信的类或对象操作，对不可信的进行信息隐藏。简单来说，封装就是把对象隐藏起来，不让外部访问。但是可以通过该对象内部的方法对对象进行访问和操作(例如set和get)\n\n流程1.将对象属性私有化，即private，这样外部不能随意为对象赋值2.提供get和set方法，这样可以验证参数的合法性。只有在参数满足条件的情况下才能进行操作\n\n继承作用：使子类具有父类的属性和方法（不包括构造方法，因为构造方法的名字是类名），还可以在子类中重新定义，追加属性和方法。其中，父类又被称为基类，超类格式：public class 子类名 extends 父类名{}用继承的好处：假设类1和类2有相同的成员变量和方法，此时如果分别定义这两个类，代码会冗余。可以先定义一个父类，包含这些成员变量和方法，再定义这两个子类，根据情况添加别的成员，这样代码会更简洁弊端：减少了子类的独立性，当父类发生改变时，子类不得不发生改变\n判断能否使用继承：多个类中存在相同的属性或方法，则抽取出相同元素放父类中。但是要注意，只有a包含b或b包含a才能算继承关系，子类包含父类(因为子类的范围更大)。例如，苹果是水果的一种，则可以把苹果当父类，水果当子类。但是狗和狮子就不能算继承关系了\n继承中的变量访问：在子类方法中访问一个变量时，先在方法内找该变量，找不到的话再从成员属性里面找，最后在父类找，再没有则报错。即遵循就近原则。方法的访问同理\n注意事项1.子类中的所有构造函数都会默认访问父类中的无参构造方法。前面讲到过，父类默认有一个无参构造方法，但是如果用户自定义了一个有参构造，则默认的那个会失效。此时子类运行会报错\n2.一个子类只能继承一个父类，即java类只支持单继承。但是java是支持多层继承的，即类1继承类2，类2继承类3\n\n类图在idea的某个类中单击鼠标右键，点击图标里的显示图，可以看到这个类中子类和父类的继承关系。再点击上方的各个图标，可以查看这些类的属性和方法\n\nsuper关键字和this一个用法，只不过查找的是父类中的局部变量和方法子类中每个构造方法的开头都默认有一句super()，即访问父类的无参构造，只不过平时不用写出来。正好对应了上面的小细节\n\n方法重写父类和子类中，方法名和传递参数一样的方法，称为子类重写父类的方法。和重载相比，方法重写要在两个类(父类和子类)中,而且参数也要一样优点：从现实角度，方法重写既延续了上一代(父类)的功能，又定义了自己的特有内容注意事项：1.私有的方法不能被重写，因为私有只能允许该类中能访问，不含子类。如果子类定义了一个和父类一模一样的private方法，则该方法是子类自己的，因为根本没继承过来。可以加注解@Override来判断是否可以重写父类中的方法。注解用法:在要判断的方法上面加@Override\n2.如果注解要判断的方法，父类中根本没有的话，注解一样会报错。因为注解是用来判断能不能将方法从父类重写到子类中\n3.子类中重写的方法的访问权限不能比父类中的该方法低，可以理解成子类在父类的基础上拓宽了范围\n\npackage（包）作用：一个文件夹，对类进行分类管理一个包内不能同时存在两个相同类名，但是两个包内可以类名的组成：包类+类名。之所以是这样，是因为文件夹里的实际结构如下所示：存放项目的文件夹\\com\\包名\\类名。同理，可以得出包名的组成：com+包名如果直接在src下面创建类的话，不会有包的名称。想要为其添加类的话，在该类代码的最上面加一句package com.包名但根据我的经验，实际结构：项目名\\src\\包名\\类名。因此遵循如下规则：为类添加一个包：package+包名，不要com。创建类：包名+类名\n新理解：包下面还能创建包，所以完整的包名可能有好几层，上面的com应该也是一个包，所以完整名为包名1.包名2.包名。。。\n\nimport（导入包）如果想直接使用其他包下的类，每次调用的时候需要打出完整路径，即包名加类名，因此需要使用import来简化代码格式：import+完整包名。import之后，调用该类时，idea会自动给出提示更简单的方法：import 包名.* ，导入该包下所有的类\n\n状态修饰符包括static（静态）和final（最终态）\nfinal能够修饰类，成员属性，成员方法作用：被final修饰的类无法被继承；被final修饰的成员方法是无法被重写的；被final修饰的成员变量，该变量的值无法被修改（所以一定要赋一个初始值）final修饰局部变量如果final修饰的局部变量是基本数据类型，则该变量的值是不能被改变的：如果final修饰的局部变量是引用类型，则该变量的地址是不能被改变的，但是该地址内的属性值是可以发生改变的举个例子，final Student student&#x3D;new Student（），则该student里的任何成员变量都可以改变，但是如果打出student&#x3D;其他地址，则程序会报错\nstatic能够修饰成员方法和成员变量，这里比final更少。通过static修饰的成员方法为静态方法，通过static修饰的成员变量为静态变量作用：被static修饰的成员变量或者方法，被该类的所有对象共享，例如，static了一个成员方法age，然后创建了一个对象1，将其age赋值为18，则之后无论创建多少个对象，他们的age都是18要注意，共享的元素是可以更新的，比如在对象1中将1赋值给static的元素a，此时类中的元素a的共享值为1，但是如果接下来在对象2中将a赋值为2，此时共享值会更新为2，但是不影响这两个a为1，这两个读取的是当前的共享值。此后如果在对象3中将a赋值为3，此时共享值更新为3，该对象中的a为2。\n虽然但是，现在的java好像不允许出现这种情况，所有对象的该值都会变成共享值，所以不用担心\n\nstatic的访问特点1.被static修饰的成员方法中不能访问未被static修饰的成员方法及变量，因为被修饰的成员方法是共享的，而未被修饰的方法和方法不能被共享\n2.被static修饰的方法或变量，在调用时不用对象名.元素名，而是用类名.元素名，因为该元素只有一种情况。这里可以得出static的一种用途：不想用创建对象的方法来访问方法或变量时（即new 类名()，对象名.元素名），将该方法或变量用static修饰，访问时可以直接使用类名\n3.常量常量的性质：定义好之后值不能被修改，可以使用final int age这种形式；常量名称全部字母大写；常量的访问直接使用类名\n综上，可以得出访问时直接使用类名的条件：该元素在类中只存在一种情况，即被static修饰的方法或变量，以及常量\n\nmain方法的细节声明main方法的固定格式(原因在下面）为psvm（String[] args），传递的参数为一个名为args的数组main方法是主程序运行的入口，由java虚拟机调用。java程序是在虚拟机上运行的，因为虚拟机和类不在一个包下，所以要调用main方法，只能用public。java虚拟机在执行main方法的时候不需要用创建对象的方法，因此只能是static。main方法在执行的时候可能会接收很多参数，因此直接遍历args数组即可知道要传递的全部参数。简单来说，数组是为了方便开发者在以后运行java程序时注入参数到main方法中\n注意事项1.main方法可以直接访问该类的静态成员，因为main被static修饰了2.main方法访问非静态成员时，要先创建对象3.在main方法的args数组里注入参数：idea里，在界面右上角有关于类的配置，在里面注入参数（前提是要先运行一次）。\n\n多态概述：同一个对象在不同时刻表现出来的不同形态前提1.有继承或实现关系(实现跟接口有关)2.有方法重写3.有父类引用指向子类（这句话的意思是，声明的是父类，实际指向的是子类）三者缺一不可关于第三点，举例如下Parent 对象名&#x3D;new Child（）\n多态的访问特点最基本的就是下面两句话，后面是对这段话的理解成员变量：编译看左边，执行看左边成员方法：编译看左边，执行看右边首先要明白一点，只有编译过了才能执行。编译指的是在编写代码的过程中idea这种软件会对代码进行检测，代码有问题则会报错。下面是一个例子，之后的例子也是和这个一样父类为Parent，子类为Cat，Dog，三个类里都有成员变量age和成员方法eat。Dog类和Cat类里有name属性。按照多态的定义，Parent parent&#x3D;new Dog()，此时如果打出parent.name,按照上面的原则，编译看左边，因为左边的parent里没name这个属性，所以idea会报错。如果在Parent里加上name属性则不会报错了。执行程序时，调用的仍然是parent里的name属性。调用成员方法时，编译阶段跟上面一样的原理。关键是执行过程，调用的是右边Dog类里的eat方法。可以从地址的角度来考虑这个问题.new Dog()时，系统在堆空间里生成了一块Dog类的空间，并将其赋给了左边的parent对象。执行的时候，系统根据parent的地址找到了右边的Dog类，并调用其中的方法和变量。\n简化版：综上所述，编译看左边是因为声明的是Parent类的对象，执行看右边是因为地址\n多态的优缺点使用多态机制，可以提高多态的拓展性。例如，调用子类成员可以不用子类实例化的方法，直接用父类对象名.成员名即可，最后调用的是子类成员\n缺点：不能使用子类独特的功能。多态能调用的方法，只有子类中的重写方法，因为编译要看左边，父类中要有该方法\n多态的转型分为向上转型和向下转型（注意，无论是向上还是向下，都是发生在父类和子类之间，猫和狗之间不能发生转型）向上：从子到父，new出子类空间给父类，正常的多态机制向下转型（也称为强转）：强制将父类转化为子类，容易发生异常\n操作：先定义一个Parent类的对象，Parent parent&#x3D;new dog()，注意这里右边不能用new Parent()，后面会讲。然后再将其强转为Dog类，Dog dog&#x3D;（Dog）Parent，括号是强制转换的意思。\n从地址角度分析，前面的流程都和上面的一样，发生强转时，由原来的Parent parent&#x3D;0x001（假定是这个地址），变成了（Dog parent）&#x3D;0x001\n当方法的参数是父类，而实参是子类时，可以自动发生向上转型，此时程序不会报错\n抽象类首先要知道两个基本概念抽象方法：只有方法声明，没有方法体的方法抽象类：只要有抽象方法就是抽象类，其他都不管\n格式：声明类或方法时，在public后面加上abstract，则该类或方法变成了抽象类型。只要是抽象类型，前面一定要用abstract修饰\n抽象类是不能生成实例的，因为它是一个抽象的概念，没有具体的实物，如上面的Parent，但是Cat和Dog类则可以生成实例，这里可以解释上面的内容如果子类中没有重写父类的方法，会默认继承父类的方法，但是如果父类中有抽象方法的话，让子类去继承显然不太合理，此时要重写该抽象方法因为概念有点多，所以可以用如下的逻辑来思考：抽象类是一个抽象的概念，不能实例化-&gt;要由其子类（注意，这个子类非抽象，即不能有抽象方法）进行实例化-&gt;子类将抽象父类的抽象方法进行重写以下关于抽象类的特点，都是基于上面这几段，所以一定要牢记\n抽象类的特点1.抽象类中不一定有抽象方法，但是有抽象方法的类必须为抽象类2.抽象类不能实例化3.抽象类必须由子类进行实例化4.子类必须对父类（抽象类）中的所有抽象方法进行重写5.在抽象类中可以定义非抽象类方法6.子类如果不想重写父类中的抽象方法，可以用abstract修饰7.抽象类中可以有构造方法，用于子类访问父类时的数据初始化\n抽象类存在的意义抽象类是一个抽象的事物，其下每个具体的实物所具有的方法都不同。从实际角度出发，公司里的各个职务都满足员工这个抽象类，而员工没有具体的方法，所以可以在员工类里创建一个抽象方法，然后让子类（即各种职务）去重写该方法，以此实现各自特定的功能\n注意事项abstract不能和以下关键字共存private：不能继承final：final修饰的方法不能被重写static：被static修饰的方法不能被重写\n接口概念：一种公共的规范准则，只要符合规范标准，大家都可以通用。简单来说，可以将其理解为对方法的抽象创建方法：把创建类时的class换成interface即可。创建完成后，还要创建一个实现类，这个类名最好用类名加Impl的形式，如CatImpl，用于实现接口。因为实现类没有继承任何父类，所以默认继承java中的object父类（所有类的祖宗），调用实现类时，先执行object类中的无参，再执行实现类中的无参格式：Public class CatImpl implements Animal实现类必须重写接口中的所有抽象方法因为和抽象类类似，不能被实例化，所以要利用多态机制。跟继承里的多态一个格式，把父类换成接口（都有抽象的特征），子类换成实现类。可以按照和抽象类一样的逻辑思考，把父类换成接口，子类换成实现类即可\n接口中的成员特点因为接口是对方法的抽象，所以可以得出以下结论接口中的方法全是抽象方法（但是在jdk8以后可以定义非抽象方法）；接口中的变量全是常量（因此可以直接用接口名.常量名来调用）。无论有没有加abs，全都默认为抽象接口中没有构造方法，因为全是常量，没有构造的必要\n猫和狗接口版本对猫和狗进行训练后，他们就能够实现跳高了。用抽象类和接口来完成该案例。思路如下抽象类：将猫和狗抽象为动物类，让猫和狗去继承接口：将跳高设置为接口，让动物类去实现跳高方法，再让猫和狗去继承\n抽象类和接口的区别（重要）可以通过对比来记忆抽象类和接口的特点。从以下三个角度考虑：设计，成员，关系设计：抽象类是对类的抽象，包括了属性和行为；接口是对行为的抽象，主要是行为成员：抽象类中有变量，常量，构造方法，抽象和非抽象方法；接口中只有常量和抽象方法（jdk8之后也能加入非抽象）\n关系：从两两间的关系来考虑类和类（继承）：只支持单继承，但支持多层继承类和接口（实现）：支持多实现，即一个类实现多个接口，还可以在继承父类的同时实现多个接口接口和接口（继承）：支持多继承，即一个接口继承多个接口由此可以看出接口的优势，因其具有多实现的特性，可以通过实现多个接口，为类附加其他的功能\n内部类定义：在类的内部再定义一个类访问特点：内部类可以直接访问外部类（这个外部类不是指外界，指的是内部类外面这个类），包括private；外部类要访问内部类，需要创建对象，格式：new 外部类（）.new 内部类（）。实际开发中，企业不会让外界访问内部类，即用private修饰内部类，但是外部类依然可以访问内部类\n分类类比成员变量和局部变量，内部类分为成员内部类和局部内部类（方法内部类），区别就在于有没有定义在方法里面。再往下分的话可以分为静态内部类和匿名内部类\n静态内部类用static修饰即可。根据前面学的static特点（可以用类名访问，静态方法里只能访问静态的成员），可以得出静态内部类的特点|1.外界可以直接用类名访问，格式为new 外部类.内部类（）2.静态内部类中要访问外部类方法的话，该方法必须也为静态\n匿名内部类先讲作用，正常情况下，原本抽象类和接口是不能直接实例化的，现在用匿名内部类即可方法： 接口名 实例化对象的名字&#x3D;new 接口名（）{}。大括号里的东西不用管，idea会给提示的。抽象类同理原理：匿名内部类中自动编写了一个实现类（名字叫NULL）。底层代码很复杂，这里先不管\n\nAPIApplication Programming Interface，应用程序编程接口，在java中指的是java封装的类库，可以简单的理解为提供各种功能的java类，只要知道怎么用即可。可以下载官方提供的api文档来查询。一些常见的功能如下sout（）；Scanner sc&#x3D;new Scanner（system.in）；new random（）；String；其中，String比较特殊，调用的时候不需要导入其所在的包（lang）JDK提供的类库大部分都在一个名为rt.jar的包下\n\nobject类前面写了，所有类都默认继承object类。object类中的方法是固定的，有一个无参构造（没有有参），所以任何类在默认情况下都会调用父类中的无参（super（）)。object中常见的方法如下clone方法，复制对象equals方法，很重要，比较两个对象的内存地址是否相等finalize方法，以后会学，jvm的垃圾回收机制getClass方法，获取某个对象所在的类，即该对象是哪个类的实例。要注意，对object类（多态向上转型）使用getClass时，显示的是其实际所在的类hashCode，之后学toString，返回对象的字符串表示形式。。。\n控制输出对象的原理即sout(对象）运行时的底层原理。当sout（stu）时（stu为对象名），输出的结果为完整类名（包名+类名）+@+神秘代码，如Main$1@41629346。鼠标对准println点击ctrl+左键，可以看到println的底层代码\n对于引用对象，底层代码如下（太多了，写了一部分）1.调用了String.valueOf(x)2.valueOf(x)方法：返回一个三元运算符，（obj&#x3D;&#x3D;null）？”null“：obj.toString（），这里的obj指的就是对象3.toString方法：return getClass（）.getName()+”@”+Integer.toHexString(hashCode())；4.@左边是类的完整类名，@右边是对象的hashcode转换成字符串形式\n\n重写toString方法为什么要重写toString：有时候需要让toString去实现其他的功能，而且上面toString输出的是地址加哈希码，不方便阅读重写方法：一般都是把toString改写成如下功能，输出对象中各属性的值。操作流程就不讲了，比较简单，而且idea中可以自动重写toString方法\n\nString作为基本数据类型的作用：保存多个字符（字符串）char：只能存一个String保存字符串的底层原理：基于数组，生成一个char类型的数组，char[] value&#x3D;[‘a’,’b’,’c’]。注意事项：其他类型的数组，sout数组名时，输出的是地址，而char类型的数组输出的是其内容，例如，sout(value)时，输出结果为abc，这个是规定，记住就行了JDK8底层使用char类型数组实现，JDK9之后就是用byte数组了\nString类中的equals方法作用：比较两个字符串是否相同格式：str1.equals(str2)，返回值为布尔类型，要注意，str1不能为空，str2能为空关于String中的equals方法，后面会细讲，所以这里少写点\n案例要求：设置一组账号和pwd，当用户输入的账号pwd与其不匹配时，输出错误。以下是几个小细节以及多个思路（优化代码的）\n1.把设置的账号和密码放在equals左边，因为用户输入的可能为空2.Scanner输入字符串：sc.nextLine()\n思路一：直接在主方法main里写完全部思路二：先在外面定义一个方法，再在main方法里执行思路三：用三元运算符控制输出结果\nObject类中的equals方法先讲双等号”&#x3D;&#x3D;”的作用对于基本数据类型：直接比大小对于引用数据类型：比地址\nobject类中的equals方法：只能比较对象的地址，不能作用于引用数据类型。这里要讲一下上面的str1.equals（str2），这句话之所以不会报错，是因为在定义完String类型的数据str1和str2后，相当于自动调用了String类，这句话里的equals实际上是String.equals\n要想让object类中的equals方法能比较两对象的内容是否相等，需要重写该equals方法\n重写Object类中的equals（重要）先看原版的equals的底层代码\npublic boolean equals(Object obj) &#123;    return (this == obj);&#125;\n\n从这段代码中可以得出一些结论1.这里面this和obj都是参数，obj是对象2，this是对象1，obj可以改成任意名字，但是this不能改，因为equals的用法是对象1.equals（对象2），底层没有给对象1留位置，所以用this代指对象1\n2.之所以obj是Object类，是利用了多态机制，所有的类都继承Object类，所以可以向上转型。\n以下是重写后的代码\npublic boolean  equals(Object obj) &#123;    if (this == obj) &#123;        return true;    &#125;    if (this.getClass() == obj.getClass()) &#123;        duixianglei obj1 = (duixianglei) obj;        if (this.name == obj1.name &amp;&amp; this.age == obj1.age) &#123;            return true;        &#125;    &#125;    return false;&#125;\n\n先讲基本思路：如果地址相同的话，直接过；判断是否是一个类；是一个类的话则判断内容是否一样\n重点在于以下细节1.为什么要用object类。因为所有类中的equals方法都是重写object类中的，各种类型数据都能调用equals方法，所以参数不能变，只能为object类，之后通过强转变回来2.为什么要将obj强制转换为原本的类型。因为多态的规则：编译看左边，执行看右边，左边的object类没有对象类中的方法，所以要转成原来的对象类才行3.对object类使用getClass方法，返回的是原本的类。后面会讲instanceof方法，比getClass方法好用4.this的类型。在哪个类里重写的equals方法，this就是哪个类的实例\n\ninstanceof方法instance：例子这个方法用来判断对象是否是一个类及其子类的实例，返回值为布尔类型格式：对象 instanceOf class(类或者接口)\n编译和执行时的要求稍微有点不同编译：class可以为对象的自身类，父类和子类，总之要和对象最少要有间接继承的关系。class是其他类的话会报错执行：根据instanceof的定义，当class为自身类和子类时返回true，当class为子类时返回false。因为子类往下不可能实例化出该对象\n用法：结合强转使用之前讲过，向下转型只能发生在有继承关系的类中，如果没有会报错，称为类型转换异常。为了防止发生这种情况，可以在每次强转语句前加一句，对象1 instanceof 类2，当返回true时再执行强转语句\n\nString类中的equals方法在源码中，String类没有继承任何类，所以默认继承object类，调用的时候可以不导包。String类重写了object类中的equals方法\n重写的代码如下（部分，实际的跟我学的不一样，所以用我自己的思路）\npublic boolean equals(Object anObject) &#123;    if (this == anObject) &#123;        return true;    &#125;\n\n所有的重写equals方法，使其能够判断对象的值是否相等，都遵循以下步骤\n1.判断地址是否一样，一样则直接过2.判断是否是同一个类（前面用的getClass方法，这里用Instanceof方法更好，因为getclass只能允许是同一个类，但instanceof可以允许父类的存在）3.向下转型，因为参数默认是object类，所以要把它变回原来的类4.判断内容是否一致\n这里稍微讲一下判断字符串的内容如何调用字符串对应的数组：value。这个东西只能在底层使用，所以外部没必要像String类一样重写equals方法。char[] s1&#x3D;value;char[] s2&#x3D;anObject.value。然后让s1和s2去比内容即可后面会讲charAt，直接用这个方法就行了\nString遍历字符串charAt：获取字符串对应的char数组中的单个元素格式：str1.charAt（index）获取字符串长度：str1.length靠这两个即可遍历整个字符串\n\nString类的替换方法replace格式：str1.replace（a，b），把a替换为b，这里的ab代指字符串，如果str1里有多个a，则全部会被替换只替换第一个a：replaceFirst，和replace一个用法替换全部的a：replaceAll，跟replace的作用差不多，区别在于replace没有用正则表达式，而这个用了，在后面会讲\n\nString类的分隔方法split用法：先在字符串str1中加入分隔符，如a|b|c|d，|为分隔符，然后用str1.split(“双斜杠+|”)，此时str1被分为了abcd四个部分，可以用str1.index调用。双斜杠是转义字符，因为| * ^是有特殊含义的字符，所以要用双斜杠转义\n\nString类的indexOf方法用法如下法一：str1.indexOf（字符串a），返回a在str1中的位置，具体为第一个字母的下标。如果有两个a，只返回第一个a的法二：str1.indexOf（字符串a，数字），从数字对应的下标开始找，可以用来找第二个a\n为什么JDK9之后字符串底层由char变成了byte节省String占用jvm的内存空间\nASCII码美国信息交换标准代码，通用的字符编码为什么要讲：因为字符串可以通过运算符和ASCII联系起来关系运算符：假如有’a’&gt;60这种式子时，a和60会被转化为ASCII码进行比较算术运算符：在进行a+60的操作时，底层用的是二进制（因为计算机底层只有二进制）的ASCII码进行相加，然后再转化为ASCII码对应的字符\n统计字符串中大小写字母和数字的个数用关系运算符，让单个字符的ASCII码去和a，A，z，Z的ASCII码比较即可，在哪个范围里即为对应的类型，这里甚至可以不知道a和A的ASCII码（只要知道a就能推出z，知道A就能推出Z），用’a’和’A’即可\n省流以下类直接略过，因为方法很多，一个个写太蠢了，要用的时候直接去查api就行。只有一个要注意的，就是这些类的特点\n1.没有构造方法，不能创造对象2.类里的其他方法都被static修饰了，要用的时候直接使用类名调用即可\nMath类System类Arrays类工具类的设计思想工具类，简单来说就是实现特定功能的类，只能被调用，由此可以得出以下结论1.构造方法用private修饰，这样不能被实例化2.方法用public修饰，这样可以直接用类名调用\n基本数据类型包装类java中一共有八种基本数据类型：四种整数（byte，short，long，int），两种浮点数，一种字符(char)，布尔（boolean）。每个基本数据类型都有其特定的包装类，这些类都继承自一个名为number的抽象类。因为包装类是类，所以要从对象的角度来分析其特征。以下以int的包装类integer来举例说明\n变量integer提供了两个变量，MAX_VALUE和MIN_VALUE，这两个变量代表的是int数据的最大值和最小值\n方法包装类和工具类不一样，有构造方法，但是已经过时了，所以现在基本不用。integer里有一个valueOf方法，该方法可以将其他类型的数据转换为int类型。这里有两个注意事项1.怎样的数据才能调用该方法。因为int里面全是数字，所以该valueOf方法只能支持数字字符串调用2.转换完之后返回的并不是int类型的数据，而是一个integer类型的对象，这个会在下面的实例化中讲到integer里还有一个intValue方法，作用是将integer对象转换为int类型数据还有很多方法，这里就省略了\n实例化首先要知道一点，integer和int有一样的用法，即integer i&#x3D;10，但是此时生成的其实是integer对象。sout i时，输出结果为10。只要是integer类的对象，都是可以直接输出的然后就是上面的valueOf方法了，因为转换完是一个integer对象，可以直接将其输出，但是要新建一个integer对象来接收它。如果想用基本数据类型int的形式来输出它，就要用到intValue方法了，讲integer对象转化为int类型再输出\n综上可以看出，int所具有的功能，integer都有，而且integer还有更多的用法。但是int的内存占用比interesting小得多，所以算是各有优势\n总结一下integer包装类的作用：将基本数据类型对象化，之后会派上用场；将别的类型数据转换为integer类对象\n"},{"url":"/2024/04/26/%E7%90%AA%E4%BA%9A%E5%A8%9C/","content":"1.三种q和普通q的伤害是一样的，只不过有有附魔加成\n2.eq能够锁定英雄，小兵则不会。对线时e小兵接qwq，注意不能李小兵太远，不然q会打小兵身上\n3.w的几个点位\n4.r闪直接对着人扔r就行，闪现调整方向\n5.er必中的条件是离对面要远一点，可以先后退一步再er\n"}]