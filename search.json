[{"title":"Hello World","url":"/2024/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java学习笔记","url":"/2024/02/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"[TOC]\n注释当行注释：&#x2F;&#x2F;注释信息多行注释：&#x2F;注释信息&#x2F; （两杠内侧各有一个*）\n\n关键字类比成语可以简化内容，如文质彬彬：形容人有礼貌关键字：java语言赋予的特定含义单词常用关键字：public，class，static，void。编译器中，写出关键字的时候会自带特殊颜色\n\n常量值是确定的。字符串常量：用双引号括起来，字符串是由字符串联起来的，字符常量和字符串常量是两个概念整数常量：不带小数点的数字小数常量:..字符常量：用单引号括起来布尔常量：表真假，只有两种结果空常量：一个特殊的值，null输出常量值：System.out.println()。括号里要不要加引号取决于输出的数据类型\n\n变量变量的值存放在内存条中常见问题1.不能同时对一个变量赋两种类型，比如先int b再char b；2.定义小数时，要在后面加f或者d，不加默认为d。比如float a&#x3D;3.14，a的类型为单精度，但是后面没加f，所以会矛盾\n\n标识符给类，方法，变量等起的名字。可以包含26字母，0-9，美元符号和下划线(#不行)规则(硬性要求)：不能以数字开头；不能是关键字(class不可以，但是Class可以)软性要求：标识符要尽量能让别人看懂是什么意思，最好别取aaa这种名字为了满足软性要求，需要使用大小驼峰命名法。这种方法只作用于标识符中每个单词的首字母\n小驼峰命名法针对方法和变量使用约定1：标识符仅一个单词时，首字母(注意这里为什么不说是全部，这是因为方便和大驼峰作对比）小写int a约定2：标识符由多个单词组成时，第一个单词的首字母小写，其余单词的首字母大写int firstAge\n大驼峰命名法针对类使用约定1：标识符是一个单词的时候，首字母大写约定2：标识符是多个单词的时候，每个单词的首字母大写\n\n类型转换自动类型转换原理：不同类型数据在内存中占的字节不同，int类型占4字节,double类型占8字节。如果用下面的句子double a&#x3D;10因为声明了a是double类型（以声明的类型为准），所以a会由赋值的10自动转换为10.00.但是，char类型不能自动转换为数字类型比如，double a&#x3D;10，char b&#x3D;a，这时会报错\n强制类型转换和自动相反，从字节大的数据转化为字节小的数据int a&#x3D;99.99，默认a是int这种方法的缺点是会损耗精度，还有可能会丢失数据，一般会报错\n\n字符的＋操作多个类型的数据相加时，遵循以下规则char类型的数据转换成ascii码，其他非字符类型的数据转换成其中占字节最多的数据类型例如，char q&#x3D;‘a’，int a&#x3D;10，float b&#x3D;10.00，则q+a+b&#x3D;117.00，因为q被转换成了97，a转换成了10.00占字节数排序(从小到大)：byte short char int long float double\n\n字符串的＋操作字符串没有ascii码，所以跟int类型数据相加时不能用上面的方法，直接做连接操作例如，int a&#x3D;10，int b&#x3D;10则a+b+“abc”&#x3D;&#x3D;20abc，但是a+“abc”+b&#x3D;&#x3D;10abc10因为加法是从左到右\n\ni++的易错点总结：i++是先将i加入操作中然后再加1，++i是先将i+1再将i加入操作int x&#x3D;10，int y&#x3D;x++ + x++ + x++第一个x++的值是10(操作为将i的值作为第一个加数），第二个x++的值是11，第三个x++的值是12，所以y的值为33\n\n关系运算符关系运算符的结果是bool类型，只有true和false两种\n\n逻辑运算符逻辑异或(^)：a^b时，ab真值不同，返回true，ab真值相同时返回false。个人理解，异指的是ab的真值相反，或指的是a真b假或a假b真\n短路逻辑运算符普通逻辑运算符只有一个符号，比如|，&amp;等。短路逻辑运算符变成了两个，比如a&amp;&amp;b。顾名思义，具有短路作用，如果a是假的，就不会再去运行b(如果b是i++&lt;100这种，i就不会自增了，因为不会运行这一句)，而普通的逻辑运算符没有此功能程序里面最好用短路，这样可以提高效率\n\n三元运算符格式：关系表达式?a:b。如果关系表达式的返回值为true，则输出a，否则输出b使用三元运算符可以减少代码量\n\nScanner(打印机)作用类似于c语言里的input，使用方法如下1.导包 import java.util.Scanner 这步必须在定义类之前2.创建对象 Scanner sc&#x3D;new Scanner(System.in)3.接收数据 int i&#x3D;sc.nextInt(注意这里i是大写)这样就把用户输入的值赋给了i\n\n流程控制语句一共有三种结构，顺序，分支，循环\nif语句跟c语言里的差不多\n\nswitch语句格式如下switch(表达式)    case 值1：        语句体1；        break；    case 值2：        语句体2；        break；。。。    default：        语句体n；        break；}表达式：可以是各种类型的数据case：要和表达式进行比较的值语句体：一系列操作break：表示中断，结束的意思，可以控制switch的结束，执行了break之后就不会再运行下面的句子了，直接跳出switchdefault：当所有的值都和表达式不匹配时，执行default下面的语句，相当于多重if语句里最后的else\n小细节1.如果表达式和case匹配之后(注意是匹配之后，有可能是第二个case)，这行操作后面没有break，接下来的case不管有没有匹配，其下面的操作都会执行，直到出现break。举例如下case 1:print(春);break;case 2:print(夏);case 3:print(秋)；case 4:print(冬);break;此时输入number&#x3D;1之后只会输出春，但是输入2的话会输出夏秋冬\n2.如果有几个case对应同一操作的话，可以写成下面这样简化代码case 1：case 2：case 3：    操作；    break；\n\nfor循环语句也是跟c语言差不多，要注意一下运行的逻辑，判断完i符合条件之后，先进行下面的操作，再将i+1.可以想象成一个逆时针的顺序\n\nwhile循环语句格式如下while(判断条件语句){    循环体语句；    控制条件语句(例如i++这种)；}\ndo while循环语句格式如下do{    循环体语句；    条件控制语句；}while(条件判断语句)；其实就是while语句换了个形式\n\n死循环将循环变成死循环：去除掉条件控制语句(例如i++这种)，这样可以让循环体语句一直执行死循环会让cpu使用率飙升\n\n三种循环语句的区别for循环中i的值只能在循环体里面使用(因为i是在for循环里定义的)while循环里的i由于是在外部定义的，因此可以在外部使用\n\nbreak和continue的区别break：结束所在的循环continue：继续下次循环\n\nRandom随机数作用：随机产生一个随机数。使用步骤如下导包：import java.util.Random;创建对象：Random r&#x3D;new Random();获取随机数：int number&#x3D;r.nextInt(10)。数据的范围：0到10，包括0但不包括10。\n\n猜随机数要求：生成一个随机数，当用户输入值小于该数时，输出”太小了”，当输入值大于该数时，输出”太大了”。匹配则输出”恭喜”思路：首先想到要用循环，而且用不了for，所以只能while。然后确定判断条件语句，用a！&#x3D;b，循环体里面用if。代码如下\nwhile(i!=j)&#123;    if(j&gt;i)&#123;        System.out.println(&quot;太大了&quot;);        j=sc.nextInt();    &#125;    if(j&lt;i)&#123;        System.out.println(&quot;太小了&quot;);        j=sc.nextInt();    &#125;\n\nidea使用idea创建项目1.创建一个空项目2.在该项目下创建新的模块3.在该模块下的src创建一个包(一个文件夹)4.在该包下新建一个类5.在该类下编写代码如果报错显示找不到或无法加载主类… ，点击界面上方的build project，清除一些缓存\n\nidea快捷键可能会跟qq等软件冲突，最好关掉这些软件的快捷键快速生成main()方法：法一：输入psvm(public static void main的缩写)，idea会弹出词条法二(懒人版）：输入m，只有这一个词条快速生成输出语句(只有在自己定义的类里面可以使用）：sout+回车注释：单行：全选，按住ctrl+&#x2F;(再按一下就是取消)多行：全选，按住ctrl+alt+&#x2F;但其实据我观察，无论是单行还是多行，都可以只按ctrl加&#x2F;格式化：ctrl+alt+l。不是清空，是让代码更加工整\n\n数组定义数组的格式：法一(推荐)：int [] arr，这句话的意思是定义了一个int类型的数组，数组的名字是arr。法二：int arr []，这句话的意思是定义了一个int类型的变量，变量名是arr数组\n\n数组初始化java中的数组必须先初始化才能使用。初始化：为数组中的每个元素分配内存空间，并为每个数组元素赋值初始化方式分动态和静态两种动态初始化：只指定数组长度，由系统为数组分配初始值。形式如下new 数据类型[数组长度]静态初始化:格式如下int[] arr&#x3D;new int[]{1，2，3}；或者直接int[] arr&#x3D;{1,2,3};\n\n单个数组访问的原理数组内存分配：java程序为了提高运算效率，在内存中对空间进行了不同区域的划分，每一篇区域都有特定的管理方式jdk内存空间分为：堆，栈，方法区，本地方法栈等假设进行如下操作：int [] arr&#x3D;new int [4];sout(arr);此时输出的结果是该数组的内存地址。这是因为，当new int [4]时，会先在堆内存空间里开辟一块空间，这块空间用来存放数组的四个元素，而int [] arr定义的数组存放在栈空间里。堆空间里存放了很多new出来的数组空间，除了上面的arr还有其他的数组空间，所以需要知道指定数组的地址才能找到指定的数组空间，而这个地址赋值给了栈空间里的arr以及各种数组如果把上面改成sout(arr[0-3]),则输出的结果全是0，这是因为数组在初始化时会为存储空间添加默认值。int类型的数组全部默认为0，浮点数类型默认为0.0，布尔类型默认为false栈内存：用来存储局部变量堆内存：存储的都是实体(对象)，即new建立的空间栈空间通过内存地址访问堆内存空间动态初始化的整个流程(用上面的例子):new int[4]在堆空间里生成了一块特定的空间用来存放四个元素，int[] arr在栈空间里生成了一个int类型的数组，new出来的空间将地址赋给了arr，在输入sout(arr[0])时，先通过arr的地址访问堆空间中的特定空间，然后访问下标为0的元素如果进行了int[] arr2&#x3D;arr1的操作，则把arr1的地址赋值给arr2\n\n如何遍历数组获取数组的长度：arr.length遍历：用for循环，i&lt;arr.length\n\n方法具有特殊功能的代码集，和c语言里的自定义函数是一个东西\n\n方法的定义与调用定义：ps+返回值类型+方法名(参数){方法体；return 返回值(这步只有在上面不为void的时候要加)}调用：方法名(参数)；注意：不能在方法里面定义方法；方法定义不能在main主程序里面方法的定义与调用也可以通过栈来理解。主程序的main方法先被压入栈底，然后再压入定义的方法。所以调用的时候定义的方法先出栈\n\n形参和实参形参：方法定义中的参数实参：方法调用中的参数\n\n带返回值的方法条件：把public static void 中的void改成具体的返回值类型，然后在方法体的下面加一行return返回值可以将返回值传递给其他参数，如int i&#x3D;geimax(a,b)，return的值是两数中更大的那个\n\n方法的重载指的是同一个类中定义的多个方法之间的关系，这些方法满足下列条件：1.多个方法在同一个类中2.多个方法具有相同的方法名3.多个方法的参数类型不同，类型不同或者数量不同简单来说，一个类中不允许创建两个一模一样的方法，但是只要在接收的参数不同(类型或者数量)的情况下，两个方法的名字是可以一样的特点：仅针对于方法的定义，与方法的调用，以及返回值都无关，不能通过两个方法的返回值判断是否重载；两个方法必须要在同一个类中\n\n方法的参数传递基本类型形参值的改变不会影响实参假如定义以下 void change( int number)方法：number&#x3D;20;主程序如下：int number&#x3D;10;change(number);在运行完主程序以后，number的值依旧为10.\n\n方法的参数传递引用类型引用类型的形参(如数组)值的改变会影响实参假如把上面的例子改成如下，number变成(int[] arr),arr[0]&#x3D;10。主程序中，int[] arr&#x3D;new int[4],change(arr)，则最后arr[0]会变成10。\n原理这个例子和上面的区别在于，这个change接收的是数组的地址，而上面的change接受的只是一个数字。上面的参数number只是名字和实参number一样，但是接收的时候只接收一个普通数字。下面的change方法在接收数组时，接收的是数组的地址，所以会指向堆中对应的数组\n\ndebugbug：指程序发生了错误debug：程序调试工具，可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序\n\n操作流程1.设置断点在行号后面的区域单击鼠标左键，此时将该行标记后，调试将从该行开始2.调试程序在开始调试后，点击f8(step over,步过)，可以查看每一步对应的结果也可以按f9，f9的作用是在有几个断点的情况下，快速跳到下一个断点\n\n断点调试如何设置条件假如有如下代码：for(int i&#x3D;0;i&lt;10;i++){sout(i);}在sout这行设置断点，然后一直f8，程序会把10次的结果全部跑一遍。如果只想看i&#x3D;8时的输出结果，在断点上面单机右键，可以设置条件。在条件中输入i&#x3D;&#x3D;8即可\n\nidea在debug模式下修改变量的值调试模式下可以看到某个变量在某一步的值，右键这个值，按f2(设置值)可以更改该变量\n\n栈帧链假如有如下代码：psv a(){sout(‘a’);b();}\npsv b(){sout(‘b’);c();}\npsv c(){sout(‘c’);a();}psvm{a();}\n从出入栈的角度来分析，先定义的方法是a，然后是b，最后是c，所以入栈顺序是a，b，c。因为栈遵循先进后出的原则，所以调用时的先后顺序为cba栈帧可以理解为方法，上面这段代码里一共有三个栈帧栈帧链对后期知识的学习有帮助\n\n面向对象对象：客观存在的事物类：可以简单的描述为对现实事物的一种描述，即具有相同属性和行为(属性和行为是对象的两个特征)的一组对象的集合例如，各种手机都有品牌名称，品牌价格，品牌规格等属性，因此手机是一个类。而小米，oppo，苹果这些手机都是实体，即对象对象行为：对象能够执行的操作类不是真实存在的，而是一个抽象的概念在idea中，一个包里可以同时存在很多个类，这些类可以互相调用方法\n\n类的组成(属性和行为)属性在类中通过成员变量来体现(类中方法外的变量)行为在类中通过成员方法来体现(和前面的方法相比去掉static关键字)\n\n类的定义步骤1.定义类2.定义成员变量(各种属性)3.定义成员方法（各种行为）用代码表示出来就很熟悉了public class 类名{1.成员属性2.成员方法(这里的方法定义时要去掉static)}\n\n对象的使用1.创建对象格式：类名 对象名&#x3D;new 类名();例子：Phone phone1&#x3D;new Phone()；这里p大写是因为phone是一个类2.使用成员变量(这里的成员变量&#x3D;属性)格式：对象名称.变量例子：phone1.brand&#x3D;“xiaomi”；3.使用成员方法(这里的成员方法&#x3D;行为)格式：对象名称.方法名例子：phone1.call();之前学的scanner也是这个，相当于调用了scanner类的nextInt方法，int i&#x3D;sc.nextInt\n\n成员变量与局部变量成员变量：类中方法外的变量(上面类的定义里说了，相当于对象的属性)局部变量：方法里的变量个人理解，类中包含成员变量和成员方法，成员变量占一部分，而局部变量在另一部分里面。可以用一个很简单的方法判断，成员变量在定义时可以不带值，比如int age，而局部变量在定义时要带具体值，如int i&#x3D;1。其他区别：1.成员变量存放在堆内存中，局部变量存放在栈内存中2.成员变量随对象存在而存在(因为成员变量是对象的属性)，局部变量随方法调用而存在，随方法结束消失要注意，定义的方法里的形参也是局部变量如果要给类里的某个成员变量赋个初始值，用this。比如this.age&#x3D;123，这样就把123赋值给了成员变量age。this要在成员方法内使用思考：为什么不先创建一个对象，然后把他的age改为123因为各个对象虽然属于同一类，但是他们的地址并不相同，只改其中一个对象的age，没法对其他对象产生影响\n\nprivate(访问修饰符)用法：在定义成员变量或成员方法的语句前加一个private，如private int age，可以让其只能在该类中访问，不被其他类使用(一个包中可以有很多个类，可以用new 类1在类2中定义一个对象)。说白了就是让某个类里的属性或行为变成私人的，外界无法对其赋值或查看\n\nget和set方法set：在类里定义一个方法，这个方法的作用是为成员变量赋值，之所以不直接用this赋值，是因为要判断赋的值符不符合条件，例子如下public void setAge(int age){if(条件){this.age&#x3D;age;}}在这个set方法中，只有当接收的age符合条件后才会将其赋值给成员变量ageget：直接获取成员变量的值。用法：对象名.get属性名(下面会讲)快捷方法：单击鼠标右键，点击生成，里面有get和set方法\n\nthis关键字具体用法：在成员方法里使用，可以配合set方法。public void getAge(int age){this.age&#x3D;age;}调用这个方法的一般是对象，this和该对象对应举个例子，定义一个手机类，想为其赋值，可以用Mobile.getAge()\n\n构造方法一种特殊的方法，可以初始化对象或者为成员变量赋值，格式如下public class 类名{    修饰符 类名(参数){}}构造方法的名字一定要与类名相同，分有参构造和无参构造\n无参构造跟前面一样的形式，如Student  st&#x3D;new Student()，new是修饰符。用来生成该类的对象\n有参构造可以传递参数，为对象中的成员赋值修饰符 类名(参1，参2,…，参n){this.name&#x3D;参1；…}要注意，类中至少有一个构造方法，如果用户没定义的话，系统会自动生成一个。如果用户定义了一个有参构造的话，系统的那个会失效，此时Student st&#x3D;new Student()会报错s\n\n封装面向对象的三个基本特征(封装，继承，多态)之一封装，指的是把客观事物封装成抽象的类，并且该类可以把自己的方法和数据只让可信的类或对象操作，对不可信的进行信息隐藏。简单来说，封装就是把对象隐藏起来，不让外部访问。但是可以通过该对象内部的方法对对象进行访问和操作(例如set和get)\n\n流程1.将对象属性私有化，即private，这样外部不能随意为对象赋值2.提供get和set方法，这样可以验证参数的合法性。只有在参数满足条件的情况下才能进行操作\n\n继承作用：使子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法格式：public class 子类名 extends 父类名{}用继承的好处：假设类1和类2有相同的成员变量和方法，此时如果分别定义这两个类，代码会冗余。可以先定义一个父类，包含这些成员变量和方法，再定义这两个子类，代码会更简洁\n"}]