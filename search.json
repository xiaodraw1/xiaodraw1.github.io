[{"title":"Hello World","url":"/2024/01/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"java学习笔记","url":"/2024/02/04/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"[TOC]\n注释当行注释：&#x2F;&#x2F;注释信息多行注释：&#x2F;注释信息&#x2F; （两杠内侧各有一个*）\n\n关键字类比成语可以简化内容，如文质彬彬：形容人有礼貌关键字：java语言赋予的特定含义单词常用关键字：public，class，static，void。编译器中，写出关键字的时候会自带特殊颜色\n\n常量值是确定的。字符串常量：用双引号括起来，字符串是由字符串联起来的，字符常量和字符串常量是两个概念整数常量：不带小数点的数字小数常量:..字符常量：用单引号括起来布尔常量：表真假，只有两种结果空常量：一个特殊的值，null输出常量值：System.out.println()。括号里要不要加引号取决于输出的数据类型数据类型分基本数据类型和引用类型，上面的这些都是基本数据类型，创建对象则为引用类型，引用类型后面会讲\n\n变量变量的值存放在内存条中常见问题1.不能同时对一个变量赋两种类型，比如先int b再char b；2.定义小数时，要在后面加f或者d，不加默认为d。比如float a&#x3D;3.14，a的类型为单精度，但是后面没加f，所以会矛盾\n\n标识符给类，方法，变量等起的名字。可以包含26字母，0-9，美元符号和下划线(#不行)规则(硬性要求)：不能以数字开头；不能是关键字(class不可以，但是Class可以)软性要求：标识符要尽量能让别人看懂是什么意思，最好别取aaa这种名字为了满足软性要求，需要使用大小驼峰命名法。这种方法只作用于标识符中每个单词的首字母\n小驼峰命名法针对方法和变量使用约定1：标识符仅一个单词时，首字母(注意这里为什么不说是全部，这是因为方便和大驼峰作对比）小写int a约定2：标识符由多个单词组成时，第一个单词的首字母小写，其余单词的首字母大写int firstAge\n大驼峰命名法针对类使用约定1：标识符是一个单词的时候，首字母大写约定2：标识符是多个单词的时候，每个单词的首字母大写\n\n类型转换自动类型转换原理：不同类型数据在内存中占的字节不同，int类型占4字节,double类型占8字节。如果用下面的句子double a&#x3D;10因为声明了a是double类型（以声明的类型为准），所以a会由赋值的10自动转换为10.00.但是，char类型不能自动转换为数字类型比如，double a&#x3D;10，char b&#x3D;a，这时会报错\n强制类型转换和自动相反，从字节大的数据转化为字节小的数据int a&#x3D;99.99，默认a是int这种方法的缺点是会损耗精度，还有可能会丢失数据，一般会报错\n\n字符的＋操作多个类型的数据相加时，遵循以下规则char类型的数据转换成ascii码，其他非字符类型的数据转换成其中占字节最多的数据类型例如，char q&#x3D;‘a’，int a&#x3D;10，float b&#x3D;10.00，则q+a+b&#x3D;117.00，因为q被转换成了97，a转换成了10.00占字节数排序(从小到大)：byte short char int long float double\n\n字符串的＋操作字符串没有ascii码，所以跟int类型数据相加时不能用上面的方法，直接做连接操作例如，int a&#x3D;10，int b&#x3D;10则a+b+“abc”&#x3D;&#x3D;20abc，但是a+“abc”+b&#x3D;&#x3D;10abc10因为加法是从左到右\n\ni++的易错点总结：i++是先将i加入操作中然后再加1，++i是先将i+1再将i加入操作int x&#x3D;10，int y&#x3D;x++ + x++ + x++第一个x++的值是10(操作为将i的值作为第一个加数），第二个x++的值是11，第三个x++的值是12，所以y的值为33\n\n关系运算符关系运算符的结果是bool类型，只有true和false两种\n\n逻辑运算符逻辑异或(^)：a^b时，ab真值不同，返回true，ab真值相同时返回false。个人理解，异指的是ab的真值相反，或指的是a真b假或a假b真\n短路逻辑运算符普通逻辑运算符只有一个符号，比如|，&amp;等。短路逻辑运算符变成了两个，比如a&amp;&amp;b。顾名思义，具有短路作用，如果a是假的，就不会再去运行b(如果b是i++&lt;100这种，i就不会自增了，因为不会运行这一句)，而普通的逻辑运算符没有此功能程序里面最好用短路，这样可以提高效率\n\n三元运算符格式：关系表达式?a:b。如果关系表达式的返回值为true，则输出a，否则输出b使用三元运算符可以减少代码量\n\nScanner(打印机)作用类似于c语言里的input，使用方法如下1.导包 import java.util.Scanner 这步必须在定义类之前2.创建对象 Scanner sc&#x3D;new Scanner(System.in)3.接收数据 int i&#x3D;sc.nextInt(注意这里i是大写)这样就把用户输入的值赋给了i\n\n流程控制语句一共有三种结构，顺序，分支，循环\nif语句跟c语言里的差不多\n\nswitch语句格式如下switch(表达式)    case 值1：        语句体1；        break；    case 值2：        语句体2；        break；。。。    default：        语句体n；        break；}表达式：可以是各种类型的数据case：要和表达式进行比较的值语句体：一系列操作break：表示中断，结束的意思，可以控制switch的结束，执行了break之后就不会再运行下面的句子了，直接跳出switchdefault：当所有的值都和表达式不匹配时，执行default下面的语句，相当于多重if语句里最后的else\n小细节1.如果表达式和case匹配之后(注意是匹配之后，有可能是第二个case)，这行操作后面没有break，接下来的case不管有没有匹配，其下面的操作都会执行，直到出现break。举例如下case 1:print(春);break;case 2:print(夏);case 3:print(秋)；case 4:print(冬);break;此时输入number&#x3D;1之后只会输出春，但是输入2的话会输出夏秋冬\n2.如果有几个case对应同一操作的话，可以写成下面这样简化代码case 1：case 2：case 3：    操作；    break；\n\nfor循环语句也是跟c语言差不多，要注意一下运行的逻辑，判断完i符合条件之后，先进行下面的操作，再将i+1.可以想象成一个逆时针的顺序\n\nwhile循环语句格式如下while(判断条件语句){    循环体语句；    控制条件语句(例如i++这种)；}\ndo while循环语句格式如下do{    循环体语句；    条件控制语句；}while(条件判断语句)；其实就是while语句换了个形式\n\n死循环将循环变成死循环：去除掉条件控制语句(例如i++这种)，这样可以让循环体语句一直执行死循环会让cpu使用率飙升\n\n三种循环语句的区别for循环中i的值只能在循环体里面使用(因为i是在for循环里定义的)while循环里的i由于是在外部定义的，因此可以在外部使用\n\nbreak和continue的区别break：结束所在的循环continue：继续下次循环\n\nRandom随机数作用：随机产生一个随机数。使用步骤如下导包：import java.util.Random;创建对象：Random r&#x3D;new Random();获取随机数：int number&#x3D;r.nextInt(10)。数据的范围：0到10，包括0但不包括10。\n\n猜随机数要求：生成一个随机数，当用户输入值小于该数时，输出”太小了”，当输入值大于该数时，输出”太大了”。匹配则输出”恭喜”思路：首先想到要用循环，而且用不了for，所以只能while。然后确定判断条件语句，用a！&#x3D;b，循环体里面用if。代码如下\nwhile(i!=j)&#123;    if(j&gt;i)&#123;        System.out.println(&quot;太大了&quot;);        j=sc.nextInt();    &#125;    if(j&lt;i)&#123;        System.out.println(&quot;太小了&quot;);        j=sc.nextInt();    &#125;\n\nidea使用idea创建项目1.创建一个空项目2.在该项目下创建新的模块3.在该模块下的src创建一个包(一个文件夹)4.在该包下新建一个类5.在该类下编写代码如果报错显示找不到或无法加载主类… ，点击界面上方的build project，清除一些缓存\n\nidea快捷键可能会跟qq等软件冲突，最好关掉这些软件的快捷键快速生成main()方法：法一：输入psvm(public static void main的缩写)，idea会弹出词条法二(懒人版）：输入m，只有这一个词条快速生成输出语句(只有在自己定义的类里面可以使用）：sout+回车注释：单行：全选，按住ctrl+&#x2F;(再按一下就是取消)多行：全选，按住ctrl+alt+&#x2F;但其实据我观察，无论是单行还是多行，都可以只按ctrl加&#x2F;格式化：ctrl+alt+l。不是清空，是让代码更加工整转大写：选中，ctrl+shift+u自动生成代码：ctrl+alt+v在idea中可以在new对象时自动为这个对象起名字等等生成初始化代码，简单来说就是自动生成等式左边的内容\n\n数组定义数组的格式：法一(推荐)：int [] arr，这句话的意思是定义了一个int类型的数组，数组的名字是arr。法二：int arr []，这句话的意思是定义了一个int类型的变量，变量名是arr数组\n\n数组初始化java中的数组必须先初始化才能使用。初始化：为数组中的每个元素分配内存空间，并为每个数组元素赋值初始化方式分动态和静态两种动态初始化：只指定数组长度，由系统为数组分配初始值。形式如下new 数据类型[数组长度]静态初始化:格式如下int[] arr&#x3D;new int[]{1，2，3}；或者直接int[] arr&#x3D;{1,2,3};\n\n单个数组访问的原理数组内存分配：java程序为了提高运算效率，在内存中对空间进行了不同区域的划分，每一篇区域都有特定的管理方式jdk内存空间分为：堆，栈，方法区，本地方法栈等假设进行如下操作：int [] arr&#x3D;new int [4];sout(arr);此时输出的结果是该数组的内存地址。这是因为，当new int [4]时，会先在堆内存空间里开辟一块空间，这块空间用来存放数组的四个元素，而int [] arr定义的数组存放在栈空间里。堆空间里存放了很多new出来的数组空间，除了上面的arr还有其他的数组空间，所以需要知道指定数组的地址才能找到指定的数组空间，而这个地址赋值给了栈空间里的arr以及各种数组如果把上面改成sout(arr[0-3]),则输出的结果全是0，这是因为数组在初始化时会为存储空间添加默认值。int类型的数组全部默认为0，浮点数类型默认为0.0，布尔类型默认为false栈内存：用来存储局部变量堆内存：存储的都是实体(对象)，即new建立的空间栈空间通过内存地址访问堆内存空间动态初始化的整个流程(用上面的例子):new int[4]在堆空间里生成了一块特定的空间用来存放四个元素，int[] arr在栈空间里生成了一个int类型的数组，new出来的空间将地址赋给了arr，在输入sout(arr[0])时，先通过arr的地址访问堆空间中的特定空间，然后访问下标为0的元素如果进行了int[] arr2&#x3D;arr1的操作，则把arr1的地址赋值给arr2\n\n如何遍历数组获取数组的长度：arr.length遍历：用for循环，i&lt;arr.length\n\n方法具有特殊功能的代码集，和c语言里的自定义函数是一个东西\n\n方法的定义与调用定义：ps+返回值类型+方法名(参数){方法体；return 返回值(这步只有在上面不为void的时候要加)}调用：方法名(参数)；注意：不能在方法里面定义方法；方法定义不能在main主程序里面方法的定义与调用也可以通过栈来理解。主程序的main方法先被压入栈底，然后再压入定义的方法。所以调用的时候定义的方法先出栈\n\n形参和实参形参：方法定义中的参数实参：方法调用中的参数\n\n带返回值的方法条件：把public static void 中的void改成具体的返回值类型，然后在方法体的下面加一行return返回值可以将返回值传递给其他参数，如int i&#x3D;geimax(a,b)，return的值是两数中更大的那个\n\n方法的重载指的是同一个类中定义的多个方法之间的关系，这些方法满足下列条件：1.多个方法在同一个类中2.多个方法具有相同的方法名3.多个方法的参数类型不同，类型不同或者数量不同简单来说，一个类中不允许创建两个一模一样的方法，但是只要在接收的参数不同(类型或者数量)的情况下，两个方法的名字是可以一样的特点：仅针对于方法的定义，与方法的调用，以及返回值都无关，不能通过两个方法的返回值判断是否重载；两个方法必须要在同一个类中\n\n方法的参数传递基本类型形参值的改变不会影响实参假如定义以下 void change( int number)方法：number&#x3D;20;主程序如下：int number&#x3D;10;change(number);在运行完主程序以后，number的值依旧为10.\n\n方法的参数传递引用类型引用类型的形参(如数组)值的改变会影响实参假如把上面的例子改成如下，number变成(int[] arr),arr[0]&#x3D;10。主程序中，int[] arr&#x3D;new int[4],change(arr)，则最后arr[0]会变成10。\n原理这个例子和上面的区别在于，这个change接收的是数组的地址，而上面的change接受的只是一个数字。上面的参数number只是名字和实参number一样，但是接收的时候只接收一个普通数字。下面的change方法在接收数组时，接收的是数组的地址，所以会指向堆中对应的数组\n\ndebugbug：指程序发生了错误debug：程序调试工具，可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序\n\n操作流程1.设置断点在行号后面的区域单击鼠标左键，此时将该行标记后，调试将从该行开始2.调试程序在开始调试后，点击f8(step over,步过)，可以查看每一步对应的结果也可以按f9，f9的作用是在有几个断点的情况下，快速跳到下一个断点\n\n断点调试如何设置条件假如有如下代码：for(int i&#x3D;0;i&lt;10;i++){sout(i);}在sout这行设置断点，然后一直f8，程序会把10次的结果全部跑一遍。如果只想看i&#x3D;8时的输出结果，在断点上面单机右键，可以设置条件。在条件中输入i&#x3D;&#x3D;8即可\n\nidea在debug模式下修改变量的值调试模式下可以看到某个变量在某一步的值，右键这个值，按f2(设置值)可以更改该变量\n\n栈帧链假如有如下代码：psv a(){sout(‘a’);b();}\npsv b(){sout(‘b’);c();}\npsv c(){sout(‘c’);a();}psvm{a();}\n从出入栈的角度来分析，先定义的方法是a，然后是b，最后是c，所以入栈顺序是a，b，c。因为栈遵循先进后出的原则，所以调用时的先后顺序为cba栈帧可以理解为方法，上面这段代码里一共有三个栈帧栈帧链对后期知识的学习有帮助\n\n面向对象对象：客观存在的事物类：可以简单的描述为对现实事物的一种描述，即具有相同属性和行为(属性和行为是对象的两个特征)的一组对象的集合例如，各种手机都有品牌名称，品牌价格，品牌规格等属性，因此手机是一个类。而小米，oppo，苹果这些手机都是实体，即对象对象行为：对象能够执行的操作类不是真实存在的，而是一个抽象的概念在idea中，一个包里可以同时存在很多个类，这些类可以互相调用方法\n\n类的组成(属性和行为)属性在类中通过成员变量来体现(类中方法外的变量)行为在类中通过成员方法来体现(和前面的方法相比去掉static关键字)\n\n类的定义步骤1.定义类2.定义成员变量(各种属性)3.定义成员方法（各种行为）用代码表示出来就很熟悉了public class 类名{1.成员属性2.成员方法(这里的方法定义时要去掉static)}\n\n对象的使用1.创建对象格式：类名 对象名&#x3D;new 类名();例子：Phone phone1&#x3D;new Phone()；这里p大写是因为phone是一个类2.使用成员变量(这里的成员变量&#x3D;属性)格式：对象名称.变量例子：phone1.brand&#x3D;“xiaomi”；3.使用成员方法(这里的成员方法&#x3D;行为)格式：对象名称.方法名例子：phone1.call();之前学的scanner也是这个，相当于调用了scanner类的nextInt方法，int i&#x3D;sc.nextInt\n\n成员变量与局部变量成员变量：类中方法外的变量(上面类的定义里说了，相当于对象的属性)局部变量：方法里的变量个人理解，类中包含成员变量和成员方法，成员变量占一部分，而局部变量在另一部分里面。可以用一个很简单的方法判断，成员变量在定义时可以不带值，比如int age，而局部变量在定义时要带具体值，如int i&#x3D;1。其他区别：1.成员变量存放在堆内存中，局部变量存放在栈内存中2.成员变量随对象存在而存在(因为成员变量是对象的属性)，局部变量随方法调用而存在，随方法结束消失要注意，定义的方法里的形参也是局部变量如果要给类里的某个成员变量赋个初始值，用this。比如this.age&#x3D;123，这样就把123赋值给了成员变量age。this要在成员方法内使用思考：为什么不先创建一个对象，然后把他的age改为123因为各个对象虽然属于同一类，但是他们的地址并不相同，只改其中一个对象的age，没法对其他对象产生影响\n\n权限修饰符一共有四种，分别是private，default，protected，public，不加的话默认为default。权限修饰符可以使用在方法，属性，类\n这四种一定要记住，面试要考\n用法：限定能够访问的对象，比如在定义成员变量或成员方法的语句前加一个private，如private int age，可以让其只能在该类中访问，不被其他类使用(一个包中可以有很多个类，可以用new 类1在类2中定义一个对象)。四种修饰符只在限定的范围上有区别\nprivate：只能在本类中被访问\ndefault：可以在同一个类和同一个包中被访问，超过这个则不行\nprotected：在default的基础上，再加一个不同包的子类(这个子类要继承该类)\npublic：怎样都行记忆的时候可以按照这个顺序\n\nget和set方法set：在类里定义一个方法，这个方法的作用是为成员变量赋值，之所以不直接用this赋值，是因为要判断赋的值符不符合条件，例子如下public void setAge(int age){if(条件){this.age&#x3D;age;}}在这个set方法中，只有当接收的age符合条件后才会将其赋值给成员变量ageget：直接获取成员变量的值。用法：对象名.get属性名(下面会讲)快捷方法：单击鼠标右键，点击生成，里面有get和set方法get和set在封装里面能用上\n\nthis关键字具体用法：在成员方法里使用，可以配合set方法。public void getAge(int age){this.age&#x3D;age;}调用这个方法的一般是对象，this和该对象对应举个例子，定义一个手机类，想为其赋值，可以用Mobile.getAge()\n\n构造方法一种特殊的方法，可以初始化对象或者为成员变量赋值，格式如下public class 类名{    修饰符 类名(参数){  }}构造方法的名字一定要与类名相同，分有参构造和无参构造\n无参构造跟前面一样的形式，如Student  st&#x3D;new Student()，new是修饰符。用来生成该类的对象。new的作用：在堆内生成一块空间。student()的作用：无参构造，在括号内加上参数即为有参构造\n有参构造可以传递参数，为对象中的成员赋值修饰符 类名(参1，参2,…，参n){this.name&#x3D;参1；…}\n也可以用类名 对象名&#x3D;new 类名（参数1，参数2，。。），这个是有参构造\n要注意，类中至少有一个构造方法，如果用户没定义的话，系统会自动生成一个。如果用户定义了一个有参构造的话，系统的那个会失效，此时Student st&#x3D;new Student()会报错s\n\n封装面向对象的三个基本特征(封装，继承，多态)之一封装，指的是把客观事物封装成抽象的类，并且该类可以把自己的方法和数据只让可信的类或对象操作，对不可信的进行信息隐藏。简单来说，封装就是把对象隐藏起来，不让外部访问。但是可以通过该对象内部的方法对对象进行访问和操作(例如set和get)\n\n流程1.将对象属性私有化，即private，这样外部不能随意为对象赋值2.提供get和set方法，这样可以验证参数的合法性。只有在参数满足条件的情况下才能进行操作\n\n继承作用：使子类具有父类的属性和方法（不包括构造方法，因为构造方法的名字是类名），还可以在子类中重新定义，追加属性和方法。其中，父类又被称为基类，超类格式：public class 子类名 extends 父类名{}用继承的好处：假设类1和类2有相同的成员变量和方法，此时如果分别定义这两个类，代码会冗余。可以先定义一个父类，包含这些成员变量和方法，再定义这两个子类，根据情况添加别的成员，这样代码会更简洁弊端：减少了子类的独立性，当父类发生改变时，子类不得不发生改变\n判断能否使用继承：多个类中存在相同的属性或方法，则抽取出相同元素放父类中。但是要注意，只有a包含b或b包含a才能算继承关系，子类包含父类(因为子类的范围更大)。例如，苹果是水果的一种，则可以把苹果当父类，水果当子类。但是狗和狮子就不能算继承关系了\n继承中的变量访问：在子类方法中访问一个变量时，先在方法内找该变量，找不到的话再从成员属性里面找，最后在父类找，再没有则报错。即遵循就近原则。方法的访问同理\n注意事项1.子类中的所有构造函数都会默认访问父类中的无参构造方法。前面讲到过，父类默认有一个无参构造方法，但是如果用户自定义了一个有参构造，则默认的那个会失效。此时子类运行会报错\n2.一个子类只能继承一个父类，即java类只支持单继承。但是java是支持多层继承的，即类1继承类2，类2继承类3\n\n类图在idea的某个类中单击鼠标右键，点击图标里的显示图，可以看到这个类中子类和父类的继承关系。再点击上方的各个图标，可以查看这些类的属性和方法\n\nsuper关键字和this一个用法，只不过查找的是父类中的局部变量和方法子类中每个构造方法的开头都默认有一句super()，即访问父类的无参构造，只不过平时不用写出来。正好对应了上面的小细节\n\n方法重写父类和子类中，方法名和传递参数一样的方法，称为子类重写父类的方法。和重载相比，方法重写要在两个类(父类和子类)中,而且参数也要一样优点：从现实角度，方法重写既延续了上一代(父类)的功能，又定义了自己的特有内容注意事项：1.私有的方法不能被重写，因为私有只能允许该类中能访问，不含子类。如果子类定义了一个和父类一模一样的private方法，则该方法是子类自己的，因为根本没继承过来。可以加注解@Override来判断是否可以重写父类中的方法。注解用法:在要判断的方法上面加@Override\n2.如果注解要判断的方法，父类中根本没有的话，注解一样会报错。因为注解是用来判断能不能将方法从父类重写到子类中\n3.子类中重写的方法的访问权限不能比父类中的该方法低，可以理解成子类在父类的基础上拓宽了范围\n\npackage（包）作用：一个文件夹，对类进行分类管理一个包内不能同时存在两个相同类名，但是两个包内可以类名的组成：包类+类名。之所以是这样，是因为文件夹里的实际结构如下所示：存放项目的文件夹\\com\\包名\\类名。同理，可以得出包名的组成：com+包名如果直接在src下面创建类的话，不会有包的名称。想要为其添加类的话，在该类代码的最上面加一句package com.包名但根据我的经验，实际结构：项目名\\src\\包名\\类名。因此遵循如下规则：为类添加一个包：package+包名，不要com。创建类：包名+类名\n新理解：包下面还能创建包，所以完整的包名可能有好几层，上面的com应该也是一个包，所以完整名为包名1.包名2.包名。。。\n\nimport（导入包）如果想直接使用其他包下的类，每次调用的时候需要打出完整路径，即包名加类名，因此需要使用import来简化代码格式：import+完整包名。import之后，调用该类时，idea会自动给出提示更简单的方法：import 包名.* ，导入该包下所有的类\n\n状态修饰符包括static（静态）和final（最终态）\nfinal能够修饰类，成员属性，成员方法作用：被final修饰的类无法被继承；被final修饰的成员方法是无法被重写的；被final修饰的成员变量，该变量的值无法被修改（所以一定要赋一个初始值）final修饰局部变量如果final修饰的局部变量是基本数据类型，则该变量的值是不能被改变的：如果final修饰的局部变量是引用类型，则该变量的地址是不能被改变的，但是该地址内的属性值是可以发生改变的举个例子，final Student student&#x3D;new Student（），则该student里的任何成员变量都可以改变，但是如果打出student&#x3D;其他地址，则程序会报错\nstatic能够修饰成员方法和成员变量，这里比final更少。通过static修饰的成员方法为静态方法，通过static修饰的成员变量为静态变量作用：被static修饰的成员变量或者方法，被该类的所有对象共享，例如，static了一个成员方法age，然后创建了一个对象1，将其age赋值为18，则之后无论创建多少个对象，他们的age都是18要注意，共享的元素是可以更新的，比如在对象1中将1赋值给static的元素a，此时类中的元素a的共享值为1，但是如果接下来在对象2中将a赋值为2，此时共享值会更新为2，但是不影响这两个a为1，这两个读取的是当前的共享值。此后如果在对象3中将a赋值为3，此时共享值更新为3，该对象中的a为2。\n虽然但是，现在的java好像不允许出现这种情况，所有对象的该值都会变成共享值，所以不用担心\n\nstatic的访问特点1.被static修饰的成员方法中不能访问未被static修饰的成员方法及变量，因为被修饰的成员方法是共享的，而未被修饰的方法和方法不能被共享\n2.被static修饰的方法或变量，在调用时不用对象名.元素名，而是用类名.元素名，因为该元素只有一种情况。这里可以得出static的一种用途：不想用创建对象的方法来访问方法或变量时（即new 类名()，对象名.元素名），将该方法或变量用static修饰，访问时可以直接使用类名\n3.常量常量的性质：定义好之后值不能被修改，可以使用final int age这种形式；常量名称全部字母大写；常量的访问直接使用类名\n综上，可以得出访问时直接使用类名的条件：该元素在类中只存在一种情况，即被static修饰的方法或变量，以及常量\n\nmain方法的细节声明main方法的固定格式(原因在下面）为psvm（String[] args），传递的参数为一个名为args的数组main方法是主程序运行的入口，由java虚拟机调用。java程序是在虚拟机上运行的，因为虚拟机和类不在一个包下，所以要调用main方法，只能用public。java虚拟机在执行main方法的时候不需要用创建对象的方法，因此只能是static。main方法在执行的时候可能会接收很多参数，因此直接遍历args数组即可知道要传递的全部参数。简单来说，数组是为了方便开发者在以后运行java程序时注入参数到main方法中\n注意事项1.main方法可以直接访问该类的静态成员，因为main被static修饰了2.main方法访问非静态成员时，要先创建对象3.在main方法的args数组里注入参数：idea里，在界面右上角有关于类的配置，在里面注入参数（前提是要先运行一次）。\n\n多态概述：同一个对象在不同时刻表现出来的不同形态前提1.有继承或实现关系(实现跟接口有关)2.有方法重写3.有父类引用指向子类（这句话的意思是，声明的是父类，实际指向的是子类）三者缺一不可关于第三点，举例如下Parent 对象名&#x3D;new Child（）\n多态的访问特点最基本的就是下面两句话，后面是对这段话的理解成员变量：编译看左边，执行看左边成员方法：编译看左边，执行看右边首先要明白一点，只有编译过了才能执行。编译指的是在编写代码的过程中idea这种软件会对代码进行检测，代码有问题则会报错。下面是一个例子，之后的例子也是和这个一样父类为Parent，子类为Cat，Dog，三个类里都有成员变量age和成员方法eat。Dog类和Cat类里有name属性。按照多态的定义，Parent parent&#x3D;new Dog()，此时如果打出parent.name,按照上面的原则，编译看左边，因为左边的parent里没name这个属性，所以idea会报错。如果在Parent里加上name属性则不会报错了。执行程序时，调用的仍然是parent里的name属性。调用成员方法时，编译阶段跟上面一样的原理。关键是执行过程，调用的是右边Dog类里的eat方法。可以从地址的角度来考虑这个问题.new Dog()时，系统在堆空间里生成了一块Dog类的空间，并将其赋给了左边的parent对象。执行的时候，系统根据parent的地址找到了右边的Dog类，并调用其中的方法和变量。\n简化版：综上所述，编译看左边是因为声明的是Parent类的对象，执行看右边是因为地址\n多态的优缺点使用多态机制，可以提高多态的拓展性。例如，调用子类成员可以不用子类实例化的方法，直接用父类对象名.成员名即可，最后调用的是子类成员\n缺点：不能使用子类独特的功能。多态能调用的方法，只有子类中的重写方法，因为编译要看左边，父类中要有该方法\n多态的转型分为向上转型和向下转型（注意，无论是向上还是向下，都是发生在父类和子类之间，猫和狗之间不能发生转型）向上：从子到父，new出子类空间给父类，正常的多态机制向下转型（也称为强转）：强制将父类转化为子类，容易发生异常\n操作：先定义一个Parent类的对象，Parent parent&#x3D;new dog()，注意这里右边不能用new Parent()，后面会讲。然后再将其强转为Dog类，Dog dog&#x3D;（Dog）Parent，括号是强制转换的意思。\n从地址角度分析，前面的流程都和上面的一样，发生强转时，由原来的Parent parent&#x3D;0x001（假定是这个地址），变成了（Dog parent）&#x3D;0x001\n当方法的参数是父类，而实参是子类时，可以自动发生向上转型，此时程序不会报错\n抽象类首先要知道两个基本概念抽象方法：只有方法声明，没有方法体的方法抽象类：只要有抽象方法就是抽象类，其他都不管\n格式：声明类或方法时，在public后面加上abstract，则该类或方法变成了抽象类型。只要是抽象类型，前面一定要用abstract修饰\n抽象类是不能生成实例的，因为它是一个抽象的概念，没有具体的实物，如上面的Parent，但是Cat和Dog类则可以生成实例，这里可以解释上面的内容如果子类中没有重写父类的方法，会默认继承父类的方法，但是如果父类中有抽象方法的话，让子类去继承显然不太合理，此时要重写该抽象方法因为概念有点多，所以可以用如下的逻辑来思考：抽象类是一个抽象的概念，不能实例化-&gt;要由其子类（注意，这个子类非抽象，即不能有抽象方法）进行实例化-&gt;子类将抽象父类的抽象方法进行重写以下关于抽象类的特点，都是基于上面这几段，所以一定要牢记\n抽象类的特点1.抽象类中不一定有抽象方法，但是有抽象方法的类必须为抽象类2.抽象类不能实例化3.抽象类必须由子类进行实例化4.子类必须对父类（抽象类）中的所有抽象方法进行重写5.在抽象类中可以定义非抽象类方法6.子类如果不想重写父类中的抽象方法，可以用abstract修饰7.抽象类中可以有构造方法，用于子类访问父类时的数据初始化\n抽象类存在的意义抽象类是一个抽象的事物，其下每个具体的实物所具有的方法都不同。从实际角度出发，公司里的各个职务都满足员工这个抽象类，而员工没有具体的方法，所以可以在员工类里创建一个抽象方法，然后让子类（即各种职务）去重写该方法，以此实现各自特定的功能\n注意事项abstract不能和以下关键字共存private：不能继承final：final修饰的方法不能被重写static：被static修饰的方法不能被重写\n接口概念：一种公共的规范准则，只要符合规范标准，大家都可以通用。简单来说，可以将其理解为对方法的抽象创建方法：把创建类时的class换成interface即可。创建完成后，还要创建一个实现类，这个类名最好用类名加Impl的形式，如CatImpl，用于实现接口。因为实现类没有继承任何父类，所以默认继承java中的object父类（所有类的祖宗），调用实现类时，先执行object类中的无参，再执行实现类中的无参格式：Public class CatImpl implements Animal实现类必须重写接口中的所有抽象方法因为和抽象类类似，不能被实例化，所以要利用多态机制。跟继承里的多态一个格式，把父类换成接口（都有抽象的特征），子类换成实现类。可以按照和抽象类一样的逻辑思考，把父类换成接口，子类换成实现类即可\n接口中的成员特点因为接口是对方法的抽象，所以可以得出以下结论接口中的方法全是抽象方法（但是在jdk8以后可以定义非抽象方法）；接口中的变量全是常量（因此可以直接用接口名.常量名来调用）。无论有没有加abs，全都默认为抽象接口中没有构造方法，因为全是常量，没有构造的必要\n猫和狗接口版本对猫和狗进行训练后，他们就能够实现跳高了。用抽象类和接口来完成该案例。思路如下抽象类：将猫和狗抽象为动物类，让猫和狗去继承接口：将跳高设置为接口，让动物类去实现跳高方法，再让猫和狗去继承\n抽象类和接口的区别（重要）可以通过对比来记忆抽象类和接口的特点。从以下三个角度考虑：设计，成员，关系设计：抽象类是对类的抽象，包括了属性和行为；接口是对行为的抽象，主要是行为成员：抽象类中有变量，常量，构造方法，抽象和非抽象方法；接口中只有常量和抽象方法（jdk8之后也能加入非抽象）\n关系：从两两间的关系来考虑类和类（继承）：只支持单继承，但支持多层继承类和接口（实现）：支持多实现，即一个类实现多个接口，还可以在继承父类的同时实现多个接口接口和接口（继承）：支持多继承，即一个接口继承多个接口由此可以看出接口的优势，因其具有多实现的特性，可以通过实现多个接口，为类附加其他的功能\n内部类定义：在类的内部再定义一个类访问特点：内部类可以直接访问外部类（这个外部类不是指外界，指的是内部类外面这个类），包括private；外部类要访问内部类，需要创建对象，格式：new 外部类（）.new 内部类（）。实际开发中，企业不会让外界访问内部类，即用private修饰内部类，但是外部类依然可以访问内部类\n分类类比成员变量和局部变量，内部类分为成员内部类和局部内部类（方法内部类），区别就在于有没有定义在方法里面。再往下分的话可以分为静态内部类和匿名内部类\n静态内部类用static修饰即可。根据前面学的static特点（可以用类名访问，静态方法里只能访问静态的成员），可以得出静态内部类的特点|1.外界可以直接用类名访问，格式为new 外部类.内部类（）2.静态内部类中要访问外部类方法的话，该方法必须也为静态\n匿名内部类先讲作用，正常情况下，原本抽象类和接口是不能直接实例化的，现在用匿名内部类即可方法： 接口名 实例化对象的名字&#x3D;new 接口名（）{}。大括号里的东西不用管，idea会给提示的。抽象类同理原理：匿名内部类中自动编写了一个实现类（名字叫NULL）。底层代码很复杂，这里先不管\n\nAPIApplication Programming Interface，应用程序编程接口，在java中指的是java封装的类库，可以简单的理解为提供各种功能的java类，只要知道怎么用即可。可以下载官方提供的api文档来查询。一些常见的功能如下sout（）；Scanner sc&#x3D;new Scanner（system.in）；new random（）；String；其中，String比较特殊，调用的时候不需要导入其所在的包（lang）JDK提供的类库大部分都在一个名为rt.jar的包下\n\nobject类前面写了，所有类都默认继承object类。object类中的方法是固定的，有一个无参构造（没有有参），所以任何类在默认情况下都会调用父类中的无参（super（）)。object中常见的方法如下clone方法，复制对象equals方法，很重要，比较两个对象的内存地址是否相等finalize方法，以后会学，jvm的垃圾回收机制getClass方法，获取某个对象所在的类，即该对象是哪个类的实例。要注意，对object类（多态向上转型）使用getClass时，显示的是其实际所在的类hashCode，之后学toString，返回对象的字符串表示形式。。。\n控制输出对象的原理即sout(对象）运行时的底层原理。当sout（stu）时（stu为对象名），输出的结果为完整类名（包名+类名）+@+神秘代码，如Main$1@41629346。鼠标对准println点击ctrl+左键，可以看到println的底层代码\n对于引用对象，底层代码如下（太多了，写了一部分）1.调用了String.valueOf(x)2.valueOf(x)方法：返回一个三元运算符，（obj&#x3D;&#x3D;null）？”null“：obj.toString（），这里的obj指的就是对象3.toString方法：return getClass（）.getName()+”@”+Integer.toHexString(hashCode())；4.@左边是类的完整类名，@右边是对象的hashcode转换成字符串形式\n\n重写toString方法为什么要重写toString：有时候需要让toString去实现其他的功能，而且上面toString输出的是地址加哈希码，不方便阅读重写方法：一般都是把toString改写成如下功能，输出对象中各属性的值。操作流程就不讲了，比较简单，而且idea中可以自动重写toString方法\n\nString作为基本数据类型的作用：保存多个字符（字符串）char：只能存一个String保存字符串的底层原理：基于数组，生成一个char类型的数组，char[] value&#x3D;[‘a’,’b’,’c’]。注意事项：其他类型的数组，sout数组名时，输出的是地址，而char类型的数组输出的是其内容，例如，sout(value)时，输出结果为abc，这个是规定，记住就行了JDK8底层使用char类型数组实现，JDK9之后就是用byte数组了\nString类中的equals方法作用：比较两个字符串是否相同格式：str1.equals(str2)，返回值为布尔类型，要注意，str1不能为空，str2能为空关于String中的equals方法，后面会细讲，所以这里少写点\n案例要求：设置一组账号和pwd，当用户输入的账号pwd与其不匹配时，输出错误。以下是几个小细节以及多个思路（优化代码的）\n1.把设置的账号和密码放在equals左边，因为用户输入的可能为空2.Scanner输入字符串：sc.nextLine()\n思路一：直接在主方法main里写完全部思路二：先在外面定义一个方法，再在main方法里执行思路三：用三元运算符控制输出结果\nObject类中的equals方法先讲双等号”&#x3D;&#x3D;”的作用对于基本数据类型：直接比大小对于引用数据类型：比地址\nobject类中的equals方法：只能比较对象的地址，不能作用于引用数据类型。这里要讲一下上面的str1.equals（str2），这句话之所以不会报错，是因为在定义完String类型的数据str1和str2后，相当于自动调用了String类，这句话里的equals实际上是String.equals\n要想让object类中的equals方法能比较两对象的内容是否相等，需要重写该equals方法\n重写Object类中的equals（重要）先看原版的equals的底层代码\npublic boolean equals(Object obj) &#123;    return (this == obj);&#125;\n\n从这段代码中可以得出一些结论1.这里面this和obj都是参数，obj是对象2，this是对象1，obj可以改成任意名字，但是this不能改，因为equals的用法是对象1.equals（对象2），底层没有给对象1留位置，所以用this代指对象1\n2.之所以obj是Object类，是利用了多态机制，所有的类都继承Object类，所以可以向上转型。\n以下是重写后的代码\npublic boolean  equals(Object obj) &#123;    if (this == obj) &#123;        return true;    &#125;    if (this.getClass() == obj.getClass()) &#123;        duixianglei obj1 = (duixianglei) obj;        if (this.name == obj1.name &amp;&amp; this.age == obj1.age) &#123;            return true;        &#125;    &#125;    return false;&#125;\n\n先讲基本思路：如果地址相同的话，直接过；判断是否是一个类；是一个类的话则判断内容是否一样\n重点在于以下细节1.为什么要用object类。因为所有类中的equals方法都是重写object类中的，各种类型数据都能调用equals方法，所以参数不能变，只能为object类，之后通过强转变回来2.为什么要将obj强制转换为原本的类型。因为多态的规则：编译看左边，执行看右边，左边的object类没有对象类中的方法，所以要转成原来的对象类才行3.对object类使用getClass方法，返回的是原本的类。后面会讲instanceof方法，比getClass方法好用4.this的类型。在哪个类里重写的equals方法，this就是哪个类的实例\n\ninstanceof方法instance：例子这个方法用来判断对象是否是一个类及其子类的实例，返回值为布尔类型格式：对象 instanceOf class(类或者接口)\n编译和执行时的要求稍微有点不同编译：class可以为对象的自身类，父类和子类，总之要和对象最少要有间接继承的关系。class是其他类的话会报错执行：根据instanceof的定义，当class为自身类和子类时返回true，当class为子类时返回false。因为子类往下不可能实例化出该对象\n用法：结合强转使用之前讲过，向下转型只能发生在有继承关系的类中，如果没有会报错，称为类型转换异常。为了防止发生这种情况，可以在每次强转语句前加一句，对象1 instanceof 类2，当返回true时再执行强转语句\n\nString类中的equals方法在源码中，String类没有继承任何类，所以默认继承object类，调用的时候可以不导包。String类重写了object类中的equals方法\n重写的代码如下（部分，实际的跟我学的不一样，所以用我自己的思路）\npublic boolean equals(Object anObject) &#123;    if (this == anObject) &#123;        return true;    &#125;\n\n所有的重写equals方法，使其能够判断对象的值是否相等，都遵循以下步骤\n1.判断地址是否一样，一样则直接过2.判断是否是同一个类（前面用的getClass方法，这里用Instanceof方法更好，因为getclass只能允许是同一个类，但instanceof可以允许父类的存在）3.向下转型，因为参数默认是object类，所以要把它变回原来的类4.判断内容是否一致\n这里稍微讲一下判断字符串的内容如何调用字符串对应的数组：value。这个东西只能在底层使用，所以外部没必要像String类一样重写equals方法。char[] s1&#x3D;value;char[] s2&#x3D;anObject.value。然后让s1和s2去比内容即可后面会讲charAt，直接用这个方法就行了\nString遍历字符串charAt：获取字符串对应的char数组中的单个元素格式：str1.charAt（index）获取字符串长度：str1.length靠这两个即可遍历整个字符串\n\nString类的替换方法replace格式：str1.replace（a，b），把a替换为b，这里的ab代指字符串，如果str1里有多个a，则全部会被替换只替换第一个a：replaceFirst，和replace一个用法替换全部的a：replaceAll，跟replace的作用差不多，区别在于replace没有用正则表达式，而这个用了，在后面会讲\n\nString类的分隔方法split用法：先在字符串str1中加入分隔符，如a|b|c|d，|为分隔符，然后用str1.split(“双斜杠+|”)，此时str1被分为了abcd四个部分，可以用str1.index调用。双斜杠是转义字符，因为| * ^是有特殊含义的字符，所以要用双斜杠转义\n\nString类的indexOf方法用法如下法一：str1.indexOf（字符串a），返回a在str1中的位置，具体为第一个字母的下标。如果有两个a，只返回第一个a的法二：str1.indexOf（字符串a，数字），从数字对应的下标开始找，可以用来找第二个a\n为什么JDK9之后字符串底层由char变成了byte节省String占用jvm的内存空间\nASCII码美国信息交换标准代码，通用的字符编码为什么要讲：因为字符串可以通过运算符和ASCII联系起来关系运算符：假如有’a’&gt;60这种式子时，a和60会被转化为ASCII码进行比较算术运算符：在进行a+60的操作时，底层用的是二进制（因为计算机底层只有二进制）的ASCII码进行相加，然后再转化为ASCII码对应的字符\n统计字符串中大小写字母和数字的个数用关系运算符，让单个字符的ASCII码去和a，A，z，Z的ASCII码比较即可，在哪个范围里即为对应的类型，这里甚至可以不知道a和A的ASCII码（只要知道a就能推出z，知道A就能推出Z），用’a’和’A’即可\n省流以下类直接略过，因为方法很多，一个个写太蠢了，要用的时候直接去查api就行。只有一个要注意的，就是这些类的特点\n1.没有构造方法，不能创造对象2.类里的其他方法都被static修饰了，要用的时候直接使用类名调用即可\n下面是由gpt生成的关于这些类的描述\nMath类它提供了很多常用的数学函数和常量，比如开方、取整、三角函数、对数函数等等。这些函数和常量在编程中可是经常需要用到的，特别是在处理数学计算、图形绘制、物理模拟等场景时。\n总的来说，Java Math类就是用来简化数学计算的，让你在编程时不再为数学烦恼！\nSystem类首先，System类可以帮助我们访问和操作系统属性，比如获取系统的环境变量、设置系统属性等。这样，我们的程序就能更灵活地适应不同的运行环境了。\n其次，System类还提供了标准输入、输出和错误输出流的功能。这样，我们的程序就能方便地与用户进行交互，接收用户的输入并显示输出结果。\n除此之外，System类还加载文件和库的方法，让我们能更方便地管理程序所需的资源。\n总的来说，Java System类就是个全能小助手，让我们的程序能更灵活地与操作系统进行交互，实现更强大的功能。如果你是个Java开发者，那一定要好好掌握它哦！\nArrays类首先，Arrays类提供了一系列静态方法来操作数组，比如排序、搜索、比较等。你可以使用它的sort()方法对数组进行排序，让数组变得井井有条；还可以使用binarySearch()方法在有序数组中查找特定元素，快速定位到目标位置。\n其次，Arrays类还提供了将数组转换为字符串的方法，比如toString()。当你需要将数组的内容输出到控制台或者日志中时，这个方法就派上用场了。它会将数组的内容以一定的格式拼接成一个字符串，方便你进行查看和调试。\n另外，Arrays类还包含了一些用于填充数组和比较数组的方法。比如fill()方法可以将指定的值填充到数组的每个位置，而equals()方法则可以比较两个数组是否相等。\n总的来说，Java Arrays类简化了数组操作的复杂性，让你可以更高效地处理数组数据。如果你经常需要与数组打交道，那么一定要好好掌握Arrays类的使用方法哦！\nDate类Java中的Date类，简单来说，就是用来表示和操作日期与时间的。它特别精确，能精确到毫秒级别。这个类提供了很多实用的方法，让我们可以轻松地获取当前日期和时间，设置特定的日期和时间，获取日期和时间的各个组成部分（比如年、月、日、小时、分钟和秒等），甚至还能比较两个日期时间的大小。\n在编程中，Date类非常常用。比如，你可能需要记录某个事件发生的时间，或者计算两个事件之间的时间间隔。这时候，Date类就能大显身手了。\n总的来说，Java的Date类是一个强大的工具，它让我们能够方便地处理日期和时间相关的任务。无论你是开发者还是普通用户，只要需要处理日期和时间，Date类都是你的好帮手。\nSimpleDateFormat类SimpleDateFormat并不是Date类中的方法。实际上，SimpleDateFormat是Java中的一个独立的类，它位于java.text包中。SimpleDateFormat的主要用途是以与语言环境有关的方式来格式化和解析日期。它允许你将日期和时间对象转换成字符串表示，或者将字符串解析成日期和时间对象。因此，SimpleDateFormat与Date类协同工作，用于处理日期和时间的格式化和解析任务，但并不是一个属于Date类的方法。\nCalendar类java.util.Calendar 类在 Java 中是用于表示特定瞬间（使用毫秒偏移量相对于历元（即 1970 年 1 月 1 日 00:00:00 GMT）的时间点）并允许你进行日期和时间的字段操作（如年、月、日、小时、分钟等）的抽象类。\nThrowable和Exception类所有错误或异常的超类\n工具类的设计思想工具类，简单来说就是实现特定功能的类，只能被调用，由此可以得出以下结论1.构造方法用private修饰，这样不能被实例化2.方法用public修饰，这样可以直接用类名调用\n基本数据类型包装类java中一共有八种基本数据类型：四种整数（byte，short，long，int），两种浮点数，一种字符(char)，布尔（boolean）。每个基本数据类型都有其特定的包装类，这些类都继承自一个名为number的抽象类。除了int和char，其他基本类型的包装类的名字都是原来的第一个字母变成大写。因为包装类是类，所以要从对象的角度来分析其特征。以下以int的包装类integer来举例说明\n变量integer提供了两个变量，MAX_VALUE和MIN_VALUE，这两个变量代表的是int数据的最大值和最小值\n方法包装类和工具类不一样，有构造方法，但是已经过时了，所以现在基本不用。integer里有一个valueOf方法，该方法可以将其他类型的数据转换为int类型。这里有两个注意事项1.怎样的数据才能调用该方法。因为int里面全是数字，所以该valueOf方法只能支持数字字符串调用2.转换完之后返回的并不是int类型的数据，而是一个integer类型的对象，这个会在下面的实例化中讲到3.integer里有一个intValue方法，作用是将integer对象转换为int类型数据4.parse+数据类型（如parseint），将别的基本类型转化为该基本类型，所以这个应该是最简单的还有很多方法，这里就省略了\n实例化首先要知道一点，integer和int有一样的用法，即integer i&#x3D;10，但是此时生成的其实是integer对象。sout i时，输出结果为10。只要是integer类的对象，都是可以直接输出的，之所以输出的不是地址，是因为底层重写了tostring方法，只要涉及到输出语句，底层就会有tostring方法然后就是上面的valueOf方法了，因为转换完是一个integer对象，可以直接将其输出，但是要新建一个integer对象来接收它。如果想用基本数据类型int的形式来输出它，就要用到intValue方法了，讲integer对象转化为int类型再输出\n综上可以看出，int所具有的功能，integer都有，而且integer还有更多的用法。但是int的内存占用比interesting小得多，所以算是各有优势。实际开发中，定义包装类更多\n总结一下integer包装类的作用：将基本数据类型对象化，之后会派上用场；将别的类型数据转换为integer类对象\n基本类型和包装类的区别（重要）存放位置基本类型：栈包装类：堆\n默认值包装类：Null基本类型：0或Null或false（对应三种大类）\n传递包装类是对引用的传递，int是对值的传递\n装箱和拆箱装箱：把基本类型包装拆箱：。。。\n举个例子，integer i&#x3D;1，这个就是包装。实际上，底层执行了valueOf方法，该方法执行了new integer（）过程，并且将1赋给了new出来对象的value拆箱：int a&#x3D;i，底层执行了intValue方法\n异常程序执行报错或者出现了不正常现象已学的异常有三种：1.访问数组元素越界，如一个数组a只有三个元素，但是要访问a[3]2.空指针异常，即实例化对象为null，如Parent p&#x3D;null3.类型转换异常，就是不同类之间进行多态强转\n程序报错时，会提示出错的行数，如java：17，指17行出错\n异常处理如果程序报错，则报错区域之后的代码不会继续运行。要想继续执行下去，可以使用如下两种方法\ntry catch格式try{可能有异常的代码} catch(异常类名 变量名（任意）){异常处理代码}；这段话的意思是，当try内的代码检测到异常时，如果该异常的类型和catch声明的异常类型匹配，则程序不会报错，执行catch内的语句，同时结束try catch，否则不会执行catch及之后的语句并报错\n如果担心catch声明的类型和检测到的不匹配，可以在try后面多写几个catch，这样能够检测的异常种类更多，此时当第一个符合条件的catch语句执行完毕，之后的catch语句都不会执行了\n上面这种方法虽然能检测多种异常，但是太蠢了，重复写很多catch。为了避免这种情况，可以将catch声明的类变为所有异常的父类：Throwable或Exception\nthrows作用：明确指出方法存在异常，并且用户必须处理该异常（try调用该方法的代码  catch或在调用该方法的代码后面继续加throws），否则会报错格式：在定义完方法后加一个throws Exception                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n编译异常和运行异常的区别异常可以分为编译异常和运行异常两大类编译时：java源代码编译成class文件，如果该期间发生异常，idea使用红叉展示，无法编译通过。必须使用try catch才能成功编译，这是强制要求运行时：java源文件已经编译成class文件，运行时可能出现的异常。没有强制要求使用try catch（因为编译不需要try catch也能通过）\n如何区分：有一个名为RuntimeException的父类，如果异常是这个类的子类，则为运行时异常，其余则为编译时异常\n如何自定义异常自定义异常的意义：比起throw抛出系统自带的类，用自定义的类能够实现更具体的功能，比如提示你具体哪里出错首先要知道，这里的异常指的是异常类，所以要新建一个异常类\n编译时异常根据上面的区分方式，只要定义一个类让其继承Exception类即可下面是AI对该异常的介绍\n要自定义编译时异常，你得按照以下步骤来：\n定义异常类：你需要创建一个新的类，这个类要继承自Exception类或其子类。比如，你可以像这样定义一个名为MyCheckedException的编译时异常类：java复制public class MyCheckedException extends Exception {  public MyCheckedException(String message) {    super(message);  }}\n在这个类中，你可以根据需要添加更多的方法和字段。\n\n抛出异常：在你的代码中，当遇到某些特定的错误情况时，你可以使用throw关键字来抛出你自定义的异常。比如：\n\njava复制public void someMethod() throws MyCheckedException {  &#x2F;&#x2F; … some code …  if (&#x2F;* some error condition *&#x2F;) {    throw new MyCheckedException(“This is a checked exception!”);  }  &#x2F;&#x2F; … more code …}\n注意，因为someMethod抛出了MyCheckedException，所以调用这个方法的地方要么需要处理这个异常（使用try-catch语句），要么也需要声明抛出这个异常。\n\n处理异常：在调用可能抛出编译时异常的方法时，你需要使用try-catch语句来处理这些异常。比如：\n\njava复制try {  someMethod();} catch (MyCheckedException e) {  &#x2F;&#x2F; Handle the exception here  e.printStackTrace();}\n这样，你就成功自定义了一个编译时异常，并在代码中使用了它！如果还有其他问题，尽管来问我吧！\n这里面throw new相当于创建了一个实例化的异常类对象，如果想要在括号里加入内容的话，定义异常时需要创建有参构造，如果不需要内容的话就不用创建了\n总结：定义异常类，根据情况定义有参构造；当需要提示错误时，抛出该异常（相当于一个人为的报错）；处理该异常运行时异常同理\n集合分三个阶段讲，因为面试的时候问的多，所以很重要1.api知识，包括list、set、map等2.常见数据结构3.源码解读\n意义为什么要用到集合首先要了解几个概念集合类：用于存储对象的容器类，底层基于各种数据结构实现框架：预先写好了的代码，一组互相关联的类和接口的集合，为开发者提供了一个方便的开发环境api：接口，定义了各种函数，相当于一本手册，可以通过该手册调用该接口内的各种方法框架和api的区别在于，框架是调用了各种api方法的一组代码，以此实现固定功能，但是api方法可以由用户根据实际情况选择性调用，从而实现不同的功能\n原生的数组在刚定义的时候就定死了容量，如int[] arr&#x3D;new int(10)，这样存放不了更多的数据，此时就要使用到集合类了\n集合框架的组成部分一图流\n\n其中黄色为接口，红色为实现类\n单列：一行只有一列数据多列（双列）：一行有两列数据  key（） value（）\n接口不能直接实例化，要用到多态机制Collection collection&#x3D;new ArrayList()其中为泛型，指集合容器只能存放str类型如果是双列集合，&lt;&gt;内要写两种数据类型\n组成部分1.collection(存放单列)list接口 数据是可以重复的   ArrayList 底层基于数组实现   LinkedList底层基于链表实现set接口 不可以重复，因此可以对数据做去重   HashSet底层基于Map集合实现\n2.Map(存放多列数据)   HashMap底层基于数组+链表（jdk1.7） 基于数组+链表+红黑树（jdk1.8）   HashTable同上\n集合类的命名一般由两个单词组成，第一个单词代表了该集合的底层原理，第二个单词代表实现的接口，所以看到一个集合类时可以从两个单词的角度来思考特点\n集合类ArrayList类特点：单列，不重复，无限容量的数组（默认容量为10，当存放元素超过10个时自动扩容）实例化：new ArrayList&lt;泛型&gt;（），接收对象可以为接口，如list&lt;泛型&gt; a(多态)，也可以为本身，即ArrayList&lt;泛型&gt; a。要注意的是，泛型只能为引用类型数据，如果想用int，char这种基本类型，可以换成其包装类，如integer方法：功能和普通数组差不多，只是调用了各种方法，具体如下ArrayList.size：返回该数组的大小                .get(i)：读取第i号位置的元素                .set(位置，元素值)：赋值                .remove(位置)：删除该位置的元素，后面的元素会往前移一位                .add(元素)：在最后一个元素的后面加上该元素(保证了有序性)，元素类型要和泛型一致\nList接口下的所有类在存入数据时，都保证了有序性，并且允许重复\n小案例创建一个ArrayList类，存放5个学生对象，并遍历一遍思路：先创建一个学生类，然后在测试类用循环生成五个对象，用add方法导入，然后用get遍历导入的时候，用下面的代码最方便Stu.add(new student(name,age))，直接把给对象赋值和导入一起做完了\nArrayList的时间复杂度及底层原理ArrayList底层是基于数组实现的，其中的增删改查的效率不同，体现在时间复杂度上（简单理解为循环次数）。下面会从增删改查四个角度说明\n增原生数组是没有自动扩容的机制的，但是ArrayList可以自动扩容，原理是ArrayList在容量不够时会创建一个新的大容量数组（一般是1.5倍），然后把原数组的内容拷贝进去，相当于要做一遍遍历，所以时间复杂度为o（n），效率较低\n删原理：把指定位置后面的元素下标都往前移动一位，时间复杂度也为o（n)，效率同样较低\n改分两种情况，第一种是根据下标查找元素，此时不用进行循环，因此时间复杂度为o（n），效率很高；第二种是根据元素值寻找元素，要从头到尾遍历，因此时间复杂度为o（1），效率较低。因此ArrayLIst集合的查找效率极高这句话是错误的，只有在根据下标查找元素时才效率高。这句话一定要记住，面试的时候可能会考\n查同上\n手写ArrayList集合自己手写一个类时，应该包括：构造方法，成员变量，方法。分析源码时也是如此放在ArrayList集合类中，成员变量应为一个obj类型的数组（底层原理）；构造方法用来实例化对象；成员方法包括增删改查等功能成员变量：public object[] data构造方法：new ArrayList（）成员方法：。。。（很多，懒得写了），反正都是用的Arrays工具类里的方法\nVector集合跟ArrayList差不多，异同点如下1.默认初始化的容量都是102.底层都是基于数组实现3.都是List接口下的子类4.ArrayList线程不安全，Vector线程的接口是安全的5.ArrayList每次扩容是原来的1.5倍，Vector每次扩容都是原来的2倍，还可以自定义扩容的容量\n案例(学生管理系统)主界面如下\n请输入选项1.增加元素2.删除元素3.修改元素4.查询元素5.退出系统\n除了5以外，其他选项按了都不会结束程序，继续进行下一次选择。下面从这五个方面分别讲解\n1.增加元素先定义一个studentAdd方法\npublic static void addStudent(String name,int age,String id)&#123;    Student stu1=new Student(name, age, id);    stu.add(stu1);&#125;\n\n这里之所以要用 static，是因为下面main方法里需要调用该方法，静态方法里不能有非静态方法当用户输入的选项为1时调用该方法\ncase 1: &#123;    System.out.println(&quot;请输入姓名&quot;);    String j = sc.next();    System.out.println(&quot;请输入年龄&quot;);    int k = sc.nextInt();    System.out.println(&quot;请输入学号&quot;);    String l = sc.next();    studentmanager.addStudent(j, k, l);    break;&#125;\n\nnextline容易出问题，所以最好用next方法\n2.删除元素+3.修改元素+4.查询元素\n为什么要三个一起讲呢，这里要从这三个功能的原理讲起这三个功能的实现，都是要根据学号检索，即用户输入某个学生的学号，系统根据这个学号查找到对应的元素，然后再执行各自的操作。如果三个方法分开来定义的话，相当于要写三次遍历的代码，很麻烦。为了解决这个问题，可以重构方法，将三个功能放到一个方法里，前面的遍历都是一样的，后面具体执行哪个功能则由一个参数控制\npublic static void choose(String id,int i)&#123;  if(i=1)&#123;    删除  &#125;  if(i=2)&#123;    修改  &#125;  if(i=3)&#123;    查询  &#125;&#125;\n\nid接收用户输入的学号，遍历找到对应的元素，i则用来控制三个不同的功能case 2&#x2F;3&#x2F;4：{\n  用户输入要检索的id;\n  choose(id,2&#x2F;3&#x2F;4)\n}ss\n5.退出系统\n法一：直接在case 5里面写一句return法二：把return改成system.exit法三：用一个参数i&#x3D;ture控制，while（i&#x3D;&#x3D;ture），在case5里输入一句i&#x3D;false\n迭代器(Iterator)集合的专用遍历方式用Collection接口接收一个ArrayList对象Collection&lt;&gt; co&#x3D;new ArrayList&lt;&gt; ()co.add(。。。)此时如果调用co.get，会发现co里根本就没有这个方法，系统会报错但如果用List接口接收，则可以调用get方法为了解决这个问题，需要使用到迭代器\n先将集合类对象转换成iterator对象（iterator是一个接口）Iterator&lt;&gt; i&#x3D;co.Iterator()然后调用i中的next方法sout(i.next())  查出第一个元素sout(i.next())  查出第二个sout(i.next())  。。。这个方法的原理是底层有一个计数器count，初始值为0，每调用一次next就会加1 \n除了用到next之外，还需要用到hasNext方法作用：判断下一个index是否有元素，有则返回ture，没有则返回false。应该和next共用的一个count通过这两个方法，可以遍历整个集合。先设置一个循环，条件为i.hasNext&#x3D;ture，然后在循环体内调用next\n手写Iterator迭代器原理：上面有写到，有的接口可以调用get方法，有的接口则不行，因此想办法把各种集合类都转换为List类型定义一个迭代器类成员List list，这个list用来接收转换后的List类型方法Iterator1 (List list)this.list&#x3D;list这里应该是用到了多态，其他类型都会被转换为List类型public object next1（）int count&#x3D;0get（this.list.get(count++))\n这里之所以用object，是因为返回值为一个对象，但是不知道集合的泛型hasNext就不写了\nList接口独有的方法getremovesetadd（index，element）：在index插入一个element，原位置自动往后挪一位\nListIterator迭代器List集合专用的迭代器，比起普通的迭代器多了一个previous方法previous：从尾到头遍历，条件是先从头到尾遍历一遍，原理很简单，和next共用一个计数器，正向遍历完之后，count变为了集合的size\n增强for循环（for each）jdk1.5之后推出的，底层基于迭代器实现，用于遍历数组和集合格式：for（int i(随便定义一个变量就行）：arr){循环体}；arr可以是数组或者集合，这种for循环用起来比传统的更方便由此可以得出三种遍历数组或集合的方式：传统&#x2F;增强for循环，迭代器\n链表（这个是数据结构，不是集合）这里和数组数据结构做一个比较数组：1.根据index下标的查询效率非常高            2.增加和删除的效率非常低而链表正好弥补了这个缺陷链表：1.增加删除的效率非常高 o（1）（这个是在头和尾增加，在中间增加的依然为o（n））            2.但是查询效率非常低  o(n)增删效率高是因为不需要扩容，且不用遍历（首尾），但是查询要遍历整个链表\n这里要说明一下，链表不能通过index访问元素，只能通过遍历的方式，但是java提供了访问头和尾节点的方法（getFirst（）和getLast（））链表分为三种类型，单向，双向和环形类比一下c语言，节点是用结构体表示的，因此在java中，节点用类（先定义一个节点类）的实例化对象表示\nLinkedList集合几个特点1.LinkedList是基于双向链表实现的，实现了List接口2.是非线程安全的3.允许元素值为null，允许重复元素4.各方法的效率（增删改查）5.实现了栈和队列的方法，因此可以作为栈，队列，双端队列来使用6.因为基于链表，所以不需要扩容\nget方法：格式为get（index）。因为链表中没有index，所以只能通过遍历，查找到第index个节点对应的值因为属于集合类，所以可以用iterator实现遍历\n底层代码成员变量：first，last，size方法：有一个LinkFirst（E e）方法和一个LinkLast（E e）方法，作用是生成新的头节点或者尾节点。具体代码就不写了构造方法：这里写一下节点的有参构造，格式为new node（pre，item，next）下面重点讲一下增删改查\nget方法底层用的是折半查找：将链表分成两部分，如果要查找的index小于size&#x2F;2，则查询左边这部分（从头到尾）；如果大于size&#x2F;2，则查询右边这部分（从尾到头）\nremove方法remove（index），在找到该元素的前提下删除该元素\nMap集合（接口）特点1.映射键值对的形式 key和value，简称为k和v2.key是不允许重复的，但是value是允许重复的，类似于学号和姓名的关系3.Map集合是散列存放数据的（存疑），例如HashMap是无序的，但是LinkedHashMap是有序的。散列：集合存储元素的顺序与遍历元素的顺序不一致\nHashMap集合初始化：new HashMap&lt;k,v&gt;存入数据：对象名.put（键，值）如果在存放数据时，有两组的键是相同的，则前面那组会被后面那组取代（直接修改前面那组的值）。存放完之后，直接sout该对象时，输出元素的顺序会和原来存放的顺序完全不一样删除数据：remove(key)，因为key是唯一的，所以只要输入key就行清空：clear（）containsKey（key）：判断是否存在该键，如果存在返回ture，不存在返回falsecontainsValue（value）：同上isEmpty（）：判断是否为空。这个函数的原理是调用size（）方法，为0则返回turesize（）：判断集合的大小\nHashSet集合底层是基于HashMap实现的，所以和HashMap有共同的特点：散列。和ArrayList集合都是在Collection接口下的，因此可以调用ArrayList中的各方法简单来说，hash-&gt;散列，set-&gt;不重复，实现Set-&gt;可以调用迭代器等方法和HashMap一样，允许存放元素为null\n泛型定义了集合存放数据的类型为什么要用到泛型jdk1.5之前，没有推出泛型，因此所有存入集合的数据都默认为object类型。这样有一个缺陷，在遍历整个集合时，要将所有的obj类型数据强转成string类型再输出，但int类型的数据时不能强转为string类型。为了解决这个问题，需要用到泛型，在定义集合时直接指定好存放数据的类型泛型可以用在方法，接口，类上，分别称为泛型方法&#x2F;接口&#x2F;类。\n个人理解泛型的特性：不确定和唯一不确定：一个泛型可以用来处理多种类型的数据唯一：所有带该泛型的参数，一旦其中一个的类型确定了，则其他参数都为该类型，不能出现第二种类型\n泛型类格式：修饰符 class 类名&lt;类型&gt;{}类型可以为任意大写字母，如T，E，K，V，用于表示泛型比起普通的类，泛型类少了类型转换和类型检查（比如要判断数据是否为某类型，是才能存入集合）的麻烦例如，新建一个泛型类public calss Student{}，则该类里所有的带T的参数都为T类型\n泛型方法格式：修饰符  返回值类型 方法名(参数)，如public  void update(T t)第一个T要不要写取决于别的地方有没有T。比如，在上面的例子中，如果整个类里只有T t这段有T，则不加前面这个会报错\n泛型接口格式跟类的一样。要注意，在定义实现类的时候，类名和接口名后面都要加\n类型通配符在不限定集合中存放的数据类型时，可以在定义集合时，在&lt;&gt;里加个问号，表示可以存放任意类型的数据(但是只能有一种)例如，定义一个方法public void set（List&lt;?&gt; list），则可以存放任意类型的数据。但是要注意，不能再定义一个add方法了，因为不知道？具体是什么类型，所以不能直接传递参数   \n上限和下限上限：List&lt;&gt; list里的内容为&lt;？ extends  类名&gt;，意思是泛型的类型可以为该类及其子类（因为泛型只能是引用类型）下限：&lt;&gt;里的内容为&lt;?  super  类名&gt;，意思是该泛型可以为该类及其父类\n泛型的原理泛型是在编译阶段限制了传递的类型，而不是运行阶段底层使用了擦除机制：将一个设置了泛型的List集合赋值给没有设置泛型的List集合，该泛型会被自动去除。在运行阶段时，class文件中的泛型都会被擦除\n可变参数作用：可以传递任意数量的参数。底层基于数组实现，将参数打包成一个数组传递给方法格式：在数据类型后面加一个…例如，定义一个求和的sum方法public int sum（int … a）{方法体}则无论是sum(1，2，3)还是sum（1，2，3，4）都是可以的，并且如果方法体为sout(a)，则输出的为一个数组的地址\n手写ArrayList集合自己手写一个类时，应该包括：构造方法，成员变量，方法。分析源码时也是如此放在ArrayList集合类中，成员变量应为一个obj类型的数组（底层原理）；构造方法用来实例化对象；成员方法包括增删改查等功能成员变量：public object[] data构造方法：new ArrayList（）成员方法：。。。（很多，懒得写了），反正都是用的Arrays工具类里的方法\nVector集合跟ArrayList差不多，异同点如下1.默认初始化的容量都是102.底层都是基于数组实现3.都是List接口下的子类4.ArrayList线程不安全，Vector线程的接口是安全的5.ArrayList每次扩容是原来的1.5倍，Vector每次扩容都是原来的2倍，还可以自定义扩容的容量\n"}]